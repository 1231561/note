# Spring框架

### Spring框架的概述

1、Spring是轻量级的开源的JavaEE框架

2、Spring对JDBC进行了简单的封装，使应用开发更加简便

3、**Spring的两个核心部分：IOC和Aop**

IOC：控制反转：将创建对象任务交给Spring来管理

Aop：面向切面：可以不修改代码来实现功能的修改加强

#### Spring5模块

![image-20220317151126648](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220317151126648.png)

### Spring的特点

1、方便解耦，简化开发

2、支持Aop编程

3、方便程序测试：自带Jbutils4测试类

4、方便和其他框架进行整合：Mybatis等框架

5、方便事务操作

6、降低API开发难度。

#### Spring框架的导入

1、新建一个普通的项目

![image-20220314153405864](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314153405864.png)

2、项目名右键选择添加框架支持，然后选择Spring

![image-20220314153451911](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314153451911.png)

#### 使用Spring框架来创建对象实例

![image-20220314153613625](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314153613625.png)

1、创建一个User对象，写上方法

```java
public class User {
    public void printf(){
        System.out.println("哈哈哈");
    }
}
```

2、在src目录下创建SpringXml配置文件（bean1.xml）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
//id为User类的别名  com.spring.User是User类的全路径名
<bean id="user" class="com.spring.User"></bean>
</beans>
```

3、创建测试类（SrpingTest）

[(ApplicationContext介绍_youcey的博客-CSDN博客_applicationcontext](https://blog.csdn.net/yangye1225/article/details/79525713)

ApplicationContext是Spring中的核心接口和容器，允许容器通过应用程序上下文环境创建、获取、管理bean。在构建容器的时候，创建对象采用的策略是立即加载的方式，即只要一读取完配置文件就立即创建配置文件中配置的对象。BeanFactory采用的是延迟加载的方式，什么时候根据id获取对象了，什么时候才真正地创建对象。
该接口具有三个常用的实现类：
1、ClassPathXmlApplicationContext：可以加载类路径下的配置文件，要求配置文件必须在类路径之下。
2、FileSystemXmlApplicationContext：可以加载磁盘中任意路径下的配置文件，要求具有访问权限。
3、AnnotationConfigApplicationContext：用于读取注解创建容器。

```java
public class SpringTest {
    @Test
    public void test(){
        //1、加载spring配置文件,ClassPathXmlApplicationContext映射到src目录下，可以直接路径可以直接写配置文件名
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        //2、获取配置创建的对象,通过spring创建对象
        User user = context.getBean("user", User.class);//"user"是配置文件里的给User类起的别名， User.class表示要创建的对象的类
        user.printf();

    }
}
```

结果：

![image-20220314154857801](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314154857801.png)

Spring框架确实能帮我们生成对象

### IOC的底层原理

#### 1、工厂模式（降低耦合度）

​		当一个类方法要调用另一个类的方法时（如下图UserService的execute方法调用UserDao类中的add方法），原始方式是在execute方法中new一个UserService类的对象实例，然后再通过对象调用add方法。

原始模式让UserService类和UserDao类的耦合度变得很高，当UserDao类的路径，方法名发生改变时，UserService要调用也都得跟在改变（导包是路径是原来的，包位置改变，导包路径也需要改变）。

![image-20220314162330857](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314162330857.png)

这时我们就可以使用工厂模式降低耦合度：

我们可以创建一个中间类，通过静态方法返回UserDao类的对象，这样execute方法调用add方法就可以不用直接new一个UserDao的对象，同时也降低了UserService类和UserDao类的耦合度。

![image-20220314162949085](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314162949085.png)

**注意：我们可以尽量降低耦合度，但是不可能将耦合度减低为0**

#### 2、反射

利用反射来进一步降低耦合度。

1、在xml配置文件里加入创建UserDao对象。

![image-20220314171207819](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314171207819.png)

2、然后将工厂类UserFactory的返回UserDao对象的方法用反射实现。

通过xml解析得到配置文件中UserDao对象的全路径classValue，然后利用反射获取UserDao类的字节码，最后调用newInstance方法来创建一个UserDao对象并返回。

![image-20220314171414367](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314171414367.png)

使用反射可以降低耦合度的原因是，当UserDao文件路径发生改变，只需要改变配置文件里的全路径，而不影响UserService的调用。

### IOC的两个实现方式（两个接口）

1、BeanFactory：Spring内部使用接口，不提供开发人员使用，加载配置文件的时候不会创建对象，在获取对象的时候才会创建对象。

2、ApplicationContext：BeanFactory的子接口，功能更加完善，一般供开发人员使用。

```java
public class SpringTest {
    @Test
    public void test(){
        //1、加载spring配置文件,ClassPathXmlApplicationContext映射到src目录下，可以直接路径可以直接写配置文件名
        BeanFactory context = new ClassPathXmlApplicationContext("bean1.xml");
        //2、获取配置创建的对象,通过spring创建对象
        User user = context.getBean("user", User.class);//"user"是配置文件里的给User类起的别名， User.class表示要创建的对象的类
        user.printf();

    }
}
```

## Bean管理

Bean管理指的是Spring创建对象(IOC)和Spring注入属性（DI）操作（注入属性就是给类成员属性赋值）。

依赖注入（DI):是在IOC的基础上才能完成。

Bean管理操作有两种实现方式

1、基于xml配置文件方式实现

2、基于注解方式实现

### 基于xml方式的Bean管理

**下面的xml都指SpringXml**

### SpringXml的命名空间和标签

**命名空间：\<beans>标签里的内容**

**有了相应的命名空间，才能使用标签，如context标签有相应的命名空间。**

![image-20220318175933659](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318175933659.png)

**标签：和html标签一样，拥有特定的方法。**

如bean标签，创建对象

context标签:文本标签

tx标签：事务标签

aop标签:面向切面标签。

### 步骤一：xml配置文件创造对象

**注意：xml配置文件创造对象会默认调用无参构造函数**

```xml
<bean id="book" class="com.spring.Book"></bean>
```

### 步骤二：

### 注入属性（set方式）

**set方式注入属性是常用的注入方式**

**配置文件中用property标签来给对象属性注入值，调用的是set方法，所有对象属性必须得有它的set方法才能用property来注入值。**

创建类属性的set方法：

```java
public class Book {
    private Integer id;
    private String name;

    public void setId(Integer id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}

```

之后使用property给对应属性注入值。

```xml
<bean id="book" class="com.spring.Book">
   <property name="id" value="12"></property>
    <property name="name" value="史记"></property>
</bean>
```

测试：

```java
@Test
public void test(){
    //1、加载spring配置文件,ClassPathXmlApplicationContext映射到src目录下，可以直接路径可以直接写配置文件名
    ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
    //2、获取配置创建的对象,通过spring创建对象
    Book book = context.getBean("book", Book.class);//"user"是配置文件里的给User类起的别名， User.class表示要创建的对象的类
    System.out.println(book);
}
```

结果：

![image-20220314200624648](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220314200624648.png)

### 注入属性（通过有参构造函数）

**当我们使用Bean标签来初始化对象时，会调用对应类的无参构造方法。**

**当对应类拥有有参构造方法而没有无参构造方法时，我们就可以通过有参构造方法注入属性。**

**有了有参构造方法注入属性，就可以不用set方法了**

1、创建有参构造函数

```java
public class Book {
    private Integer id;
    private String name;

    public Book(Integer id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```

2、xml配置文件:因为配置文件创建对象会调用无参构造函数，如果声明有参构造函数，而不声明无参构造函数，则需要加上constructor-arg标签来完成注入。下面两种方式都可以注入。

```xml
    <bean id="book" class="com.spring.Book">
<!--        <constructor-arg index="0" value="12"/>-->
<!--        <constructor-arg index="1" value="史记"/>-->
        <constructor-arg name="id" value="13"/>
        <constructor-arg name="name" value="西游记"/>
    </bean>
```

#### 注入属性的值有特殊符号

value值里可用\<![CDATA[含特殊字符]]>将带特殊字符的值全部转义

```xml
<property name="name" >
    <value><![CDATA[<<哈哈哈>>]]></value>
</property>
```

#### 注入外部Bean（注入外部类对象）

当一个类的属性是外部类的对象，我们可用set方法，并在配置文件给属性注入对象。

UserService类：

```java
public class UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    
    public void print(){
        System.out.println("UserService....");
        userDao.printf();
    }
}
```

UserDao类：

```java
public class UserDao {
    public void printf(){
        System.out.println("UserDao....");
    }
}
```

xml配置文件给UserService的 UserDao属性注入 UserDao对象

```xml
<bean id="UserDao" class="com.userdao.UserDao"></bean>
<bean id="UserService" class="com.userservice.UserService">
        <property name="userDao" ref="UserDao"></property>
</bean>
```

### 级联赋值

级联赋值就是在一个bean对象中注入另一个bean对象（外部bean）的属性并对该属性进行赋值

#### 方式1：注入内部Bean

有两个类，一个员工类和部门类，一个部门可用有多个员工，一对多关系。

员工类：

```java
public class Emp {
    private String name;
    private String gender;
    private Dept dept;
    public void setName(String name) {
        this.name = name;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public void setDept(Dept dept) {
        this.dept = dept;
    }
    public void print(){
        System.out.println("名字"+name+"性别"+gender+"部门"+dept);
    }

}
```

部门类：

```java
public class Dept {
    private String DeptName;

    public void setDeptName(String deptName) {
        DeptName = deptName;
    }

    @Override
    public String toString() {
        return "Dept{" +
                "DeptName='" + DeptName + '\'' +
                '}';
    }
}
```

注入内部Bean：

```xml
        <bean id="emp" class="com.emp.Emp">
            <property name="name" value="Jack"></property>
            <property name="gender" value="man"></property>
<!--            内部bean注入-->
            <property name="dept">
                <bean id="dept" class="com.dept.Dept">
                    <property name="deptName" value="财务部"></property>
                </bean>
            </property>
        </bean>
</beans>
```

测试：

```java
@Test
public void test(){
    //1、加载spring配置文件,ClassPathXmlApplicationContext映射到src目录下，可以直接路径可以直接写配置文件名
    ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml");
    //2、获取配置创建的对象,通过spring创建对象
    Emp emp = context.getBean("emp", Emp.class);//"user"是配置文件里的给User类起的别名， User.class表示要创建的对象的类
    emp.print();

}
```

结果：

名字Jack性别man部门Dept{DeptName='财务部'}

#### 方式2：注入外部Bean

```xml
      <bean id="emp" class="com.emp.Emp">
            <property name="name" value="Jack"></property>
            <property name="gender" value="man"></property>
            <property name="dept" ref="dept"></property>
        </bean>
<!--            外部Bean注入-->
    <bean id="dept" class="com.dept.Dept">
        <property name="deptName" value="财务部"></property>
    </bean>
```

测试：

```java
@Test
public void test(){
    //1、加载spring配置文件,ClassPathXmlApplicationContext映射到src目录下，可以直接路径可以直接写配置文件名
    ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml");
    //2、获取配置创建的对象,通过spring创建对象
    Emp emp = context.getBean("emp", Emp.class);//"user"是配置文件里的给User类起的别名， User.class表示要创建的对象的类
    emp.print();

}
```

结果：

名字Jack性别man部门Dept{DeptName='财务部'}

### xml注入集合

创建一个有多个集合的对象

```java
public class Collection {
    private String arr[];
    private List<String> list;
    private Map<String,String> map;
    private Set<String> set;

    public void setArr(String[] arr) {
        this.arr = arr;
    }

    public void setList(List<String> list) {
        this.list = list;
    }

    public void setMap(Map<String, String> map) {
        this.map = map;
    }

    public void setSet(Set<String> set) {
        this.set = set;
    }

    public void print(){
        System.out.println(Arrays.toString(arr));
        System.out.println(list);
        System.out.println(map);
        System.out.println(set);
    }
}
```

xml注入：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="collection" class="com.springcollection.Collection">
<!--            数组注入-->
            <property name="arr">
                <array>
                    <value>张三</value>
                    <value>李四</value>
                </array>
            </property>
<!--            list集合注入-->
            <property name="list">
                <list>
                    <value>张三</value>
                    <value>李四</value>
                </list>
            </property>
<!--            map集合注入-->
            <property name="map">
                <map>
                    <entry key="1" value="张三"></entry>
                    <entry key="2" value="李四"></entry>
                </map>
            </property>
<!--            set集合注入-->
            <property name="set">
                <set>
                    <value>张三</value>
                    <value>李四</value>
                </set>
            </property>

        </bean>
</beans>
```

测试:

```java
@Test
public void test(){
    ApplicationContext context=new ClassPathXmlApplicationContext("collection.xml");
    Collection coll = context.getBean("collection", Collection.class);
    coll.print();
}
```

结果：
[张三, 李四]
[张三, 李四]
{1=张三, 2=李四}
[张三, 李四]

### xml注入对象类型集合

学生类：

```java
public class Student {
    private String name;
    //list集合存放学生的课程
        private List<Course> list;

    public void setList(List<Course> list) {
        this.list = list;
    }
    public void print(){
        System.out.println("名字"+name+"课程"+list);
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

课程类：

```java
public class Course {
    private String courseName;

    public void setCourseName(String courseName) {
        this.courseName = courseName;
    }

    @Override
    public String toString() {
        return "Course{" +
                "courseName='" + courseName + '\'' +
                '}';
    }
}
```

xml配置注入：注入外部Bean

注意在集合中注入对象不能使用注入内部Bean。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="student" class="com.springtest2.Student">
            <property name="name" value="张三"></property>
            <property name="list">
                <list>
                    <ref bean="course1"></ref>
                    <ref bean="course2"></ref>
                </list>
            </property>
        </bean>
                <bean id="course1" class="com.springtest2.Course">
                    <property name="courseName" value="数学"></property>
                </bean>
                    <bean id="course2" class="com.springtest2.Course">
                        <property name="courseName" value="语文"></property>
                    </bean>
</beans>
```

### xml将集合提取出来

学生类：

```java
public class Student {
    private String name;
        private List<String> list;

    public void setList(List<String> list) {
        this.list = list;
    }
    public void print(){
        System.out.println("名字"+name+"课程"+list);
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

xml注入给学生类的list集合注入课程list集合

注意：加上 xmlns:util="http://www.springframework.org/schema/util"

和 http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd">

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd">

    <util:list id="courseList">
        <value>物理</value>
        <value>化学</value>
        <value>生物</value>
    </util:list>
    <bean id="student" class="com.springtest2.Student">
        <property name="name" value="李四"></property>
        <property name="list" ref="courseList"></property>
    </bean>
</beans>
```

### 工厂Bean

我们知道，普通Bean在xml配置文件中的class（类的全路径）中设置哪个类的路径，Spring就会帮你创建哪个类的对象。

例如：一个普通Bean

xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="myBean" class="com.factorybean.MyBean"></bean>
</beans>
```

测试：

```java
@Test
public void test(){
    ApplicationContext context=new ClassPathXmlApplicationContext("bean4.xml");
   MyBean myBean= context.getBean("myBean", MyBean.class);
    System.out.println(myBean);
}
```

普通Bean只能生成MyBean类对象myBean，如果想在getBean生成其他对象会报错。

**如果是工厂Bean就可以生成和配置文件规定生成的不一样的对象。**

实例：

让MyBean实现接口FactoryBean，让自己也成为工厂Bean，然后重写getObject()方法，另一个类的对象。

```java
public class MyBean implements FactoryBean {
    @Override
    public Object getObject() throws Exception {
        Course course = new Course();
        course.setCourseName("历史");
        return course;
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return FactoryBean.super.isSingleton();
    }
}
```

xml：xml没变

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="myBean" class="com.factorybean.MyBean"></bean>
</beans>
```

测试：

```java
public class XmlTest {
    @Test
    public void test(){
        ApplicationContext context=new ClassPathXmlApplicationContext("bean4.xml");
       Course course= context.getBean("myBean", Course.class);
        System.out.println(course);
    }
}
```

结果：能输出Course对象

![image-20220315155242034](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220315155242034.png)

## Bean作用域和声明周期（重要）

**Bean的作用域：Spring创建bean实例时是单实例还是多实例。**

**如何判断Spring创建bean实例：**

测试创建两个对象，看看他们的地址是否相同，如果相同就是单实例，如果不同就是多实例

Spring创建bean实例默认是单实例。

例如：

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="myBean" class="com.factorybean.MyBean" ></bean>
</beans>
```

```java
@Test
public void test(){
    ApplicationContext context=new ClassPathXmlApplicationContext("bean4.xml");
   MyBean myBean1= context.getBean("myBean", MyBean.class);
    MyBean myBean2= context.getBean("myBean", MyBean.class);
    System.out.println(myBean1);
    System.out.println(myBean2);
}
```

结果：地址相同，是单实例

![image-20220315161933093](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220315161933093.png)

**如何设置单实例和多实例？**

通过配置文件的Bean标签的scope属性设置

如单实例：不设置也默认是单实例

```xml
<bean id="myBean" class="com.factorybean.MyBean" scope="singleton" ></bean>
```

多实例：

```xml
<bean id="myBean" class="com.factorybean.MyBean" scope="prototype" ></bean>
```

测试多实例：

```java
@Test
public void test(){
    ApplicationContext context=new ClassPathXmlApplicationContext("bean4.xml");
   MyBean myBean1= context.getBean("myBean", MyBean.class);
    MyBean myBean2= context.getBean("myBean", MyBean.class);
    System.out.println(myBean1);
    System.out.println(myBean2);
}
```

结果：地址不同，是多实例

![image-20220315162452165](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220315162452165.png)

#### Bean的生命周期（很重要，面试可能会问）

Bean的生命周期有七步

1、通过构造器创建Bean实例(无参构造函数)

2、为Bean的属性设置值和对其他Bean引用(set方法)

3、把Bean实例传递给Bean后置处理器的方法

4、调用Bean的初始化的方法。（需要配置初始化的方法）

5、把Bean实例传递给Bean后置处理器的方法

6、可以获取到Bean对象了

7、关闭容器的时候，调用Bean的销毁方法（需要进行配置销毁方法）

接下来用测试来演示Bean的生命周期

**创建Order对象：**

```java
public class Order {
    private String name;
    Order(){
        System.out.println("第一步，无参构造函数被调用了");
    }

    public void setName(String name) {
        this.name = name;
        System.out.println("第二步，调用set方法，属性值被设置了");
    }
    public void initFunction(){
        System.out.println("第四步，初始化方法被调用了");
    }
    public void destroyFunction(){
        System.out.println("第七步，Bean对象被销毁了");
    }
}
```

**编写SpringXml配置文件：**

为了更清楚的看清这七步的具体实现顺序，我们自己创建了Bean初始化方法、Bean销毁方法、后置处理器方法。Bean初始化方法、Bean销毁方法、后置处理器方法都要再配置文件里配置来调用自己创建的方法。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="order" class="com.BeanLive.Order" init-method="initFunction" destroy-method="destroyFunction">
            <!--    调用Set方法-->
            <property name="name" value="张三"></property>
        </bean>
<!--    配置后置处理器-->
<!--    后置处理器会给每一个Bean对象加上后置处理器的方法，即该配置文件的所有Bean都会调用后置处理器的方法-->
        <bean id="MyBeanPost" class="com.BeanLive.MyBeanPost"></bean>
</beans>
```

**创建后置处理器接口的实现类：**

**后置处理器**：**后置处理器会给每一个Bean对象加上后置处理器的方法，即该配置文件的所有Bean都会调用后置处理器的方法**，**类似于Filter（拦截器）**。

```java
public class MyBeanPost implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第三步，初始化前，把Bean实例传递给Bean后置处理器");
        return bean;
    }
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第五步，初始化后，把Bean实例传递再给Bean后置处理器");
        return bean;
    }

}
```

测试：ClassPathXmlApplicationContext是ApplicationContext的子类，它有close()方法，可以手动销毁Bean对象。

```java
@Test
public void test2(){
    ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("bean5.xml");
    Order order = context.getBean("order", Order.class);
    System.out.println("第六步，可以获取到Bean对象了");
    context.close();
}
```

结果：

![image-20220315185215056](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220315185215056.png)

### 自动装配

用了自动装配，我们就可以不用，手动的用property标签给属性注入值了。

自动装配有两种方式

1、根据属性名装配

2、根据属性所属类装配

实例：

Emp类(员工类)

```java
public class Emp {
    private String name;
    private String gender;
    private Dept dept;
    public void setName(String name) {
        this.name = name;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public void setDept(Dept dept) {
        this.dept = dept;
    }
    public void print(){
        System.out.println("名字"+name+"性别"+gender+"部门"+dept);
    }

}
```

Dept类(部门类)

```java
public class Dept {
    private String DeptName;

    public void setDeptName(String deptName) {
        DeptName = deptName;
    }

    @Override
    public String toString() {
        return "Dept{" +
                "DeptName='" + DeptName + '\'' +
                '}';
    }
}
```

自动装配配置文件：

 autowire="byName"表示根据属性名字自动装配，所以要装配的Bean id要和类中定义的属性名一样。

 autowire="byType表示根据属性所属类自动装配，要求 class值相同的对象只能装配一个。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--    autowire="byName"表示根据属性名字自动装配-->
        <bean id="emp" class="com.autowire.Emp" autowire="byName">
            <!--    autowire="byName"表示根据属性所属类自动装配-->
         <!--   <bean id="emp" class="com.autowire.Emp" autowire="byType">-->
            <property name="name" value="张三"></property>
            <property name="gender" value="男"></property>
        </bean>
        <bean id="dept" class="com.autowire.Dept">
            <property name="deptName" value="财务部"></property>
        </bean>
</beans>
```

### Bean管理外部文件的读取和注入（xml）

**我们可以使用SpringXml配置文件来配置连接池**

下面以德鲁伊连接池为实例：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                          http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd">
<!--        配置连接池方式一：直接配置-->
    <bean id="DataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/userDb"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
    <!--配置连接池方式二：读取外部配置文件-->
    <!--    获取外部文件-->
    <context:property-placeholder location="classpath:Druid.properties"></context:property-placeholder>
<!--配置连接池-->
    <bean id="DataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${prop.driverClass}"></property>
        <property name="url" value="${prop.url}"></property>
        <property name="username" value="${prop.username}"></property>
        <property name="password" value="${prop.password}"></property>
    </bean>
</beans>
```

需要读取的外部文件：

```properties
prop.driverClass=com.mysql.cj.jdbc.Driver
prop.url=jdbc:mysql://localhost:3306/userDb
prop.username=root
prop.password=123456
```

### 基于注解实现Bean管理

**注解的简介：**

1、注解是代码特殊标记，格式：@注解名(属性名称1=属性值1，属性名称2=属性值2.....)

2、注解可以再类、方法、属性上面使用

3、使用注解是为了简化xml配置

**Spring针对Bean管理中创建对象提供下面四个注解**

1、@Component (一般用在pojo类)

2、@Service (一般用在Serive层)

3、@Controller（一般用在Web层）

4、@Repository (一般用在Dao层))

这四个注解一般用来标记类，并把这些类纳入进spring容器中管理。 

**上面四个注解的功能是一样的，都可以用来创建bean实例，而且使用位置也没有固定的位置。**

### 使用注解创建对象步骤：

**第一步、引入依赖**

引入spring-aop依赖

**第二步、在xml配置文件开启注解扫描**

**指定注解扫描范围**

注意加上context的命名空间。

下面就是扫描注解的配置语句，扫描范围可以是指定包的上一级目录，也可是具体包，越精细扫面越快，可以用逗号将几个要扫描的包名隔开。

<context:component-scan base-package="包的路径">\</context:component-scan>

**<context:component-scan base-package="com.spring.service">\</context:component-scan>**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
        <context:component-scan base-package="com.spring.service"></context:component-scan>
</beans>
```

**第三步：给要创建对象的类上加上注解**

注解的value相当于xml创建对象时bean标签id的值，注解标记的位置就相当于bean标签的class值(类的全路径)

```java
import org.springframework.stereotype.Component;
//value可以不写，不写默认将类名的首字母改为小写，返回搜索结果
//上面提到的四个注解都可以用，效果也一样
@Component(value = "userService")
public class UserService {
    public void print(){
        System.out.println("通过注解找到了这个类，并创建了一个对象了");
    }
}
```

**第四步：根据搜索结果创建对象**

```java
    @Test
    public  void  test1(){
        ApplicationContext context=new ClassPathXmlApplicationContext("bean1.xml");
 		//getBean里的userService要和搜索到的注解的值一样，代表你根据这个注解找到了类，并创建它的对象。
        UserService userService = context.getBean("userService", UserService.class);
        userService.print();
    }
}
```

### 组件扫描配置

注解的扫描一般可以分下面三种情况：

情况一：对所有指定包下的所有注解进行扫描：

```xml
<!--   情况一：     搜索com.spring包下的所有注解-->
        <context:component-scan base-package="com.spring"></context:component-scan>
```

情况二:搜索指定的注解

```xml
<!--    情况二：           use-default-filters="false"表示不会搜索所有的注解，include-filter type="annotation"表示搜索包含以下注解Component，expression表示需要筛选的注解 -->
        <context:component-scan base-package="com.spring" use-default-filters="false">
                <context:include-filter type="annotation"
                                        expression="org.springframework.stereotype.Component"/>
        </context:component-scan>
```

情况三：搜索除了指定的注解的其他所有注解

```xml
<!--     情况三：   exclude-filter type="annotation"表示搜索不包含以下注解Component-->
        <context:component-scan base-package="com.spring">
                <context:exclude-filter type="annotation"
                                        expression="org.springframework.stereotype.Component"/>
        </context:component-scan>
```

### 基于注解方式实现属性注入

实现属性的注入用到的注解一般有下面四个：

1、@Autowired：根据属性类型进行自动装配

2、@Qualifier:根据属性名称进行注入

3、@Resource：既可以根据类型注入，也可以根据名称注入

4、@Value：注入普通类型属性

#### @Autowired和@Qualifier

​		**当我们需要给一个接口类型的属性注入它的实现类对象（多态），而且它的实现类也只有一个时，我们就可以单独使用@Autowired注解注入。**

**实例：给UserService类中的UserDao接口属性注入UserDao接口的实现类UserDaoImpl对象**

1、首先得给UserService类和UserDaoImpl类用注解分别创建对象。

UserService类：

```java
import com.spring.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
//@Service创建UserServicel类的对象
@Service
public class UserService {
    // @Autowired标记在需要注入的属性上面，@Autowired根据要注入的属性类型进行注入
    @Autowired
    private UserDao dao;//@Autowired找到UserDao类型的对象进行注入
    public void print(){
        System.out.println("service");
        dao.print();
    }
}
```

UserDao接口：

```java
public interface UserDao {
    public void print();
}
```

UserDaoImpl1实现类：

```java
import org.springframework.stereotype.Repository;
//@Repository创建UserDaoImpl1类的对象
@Repository
public class UserDaoImpl1 implements UserDao{
    @Override
    public void print() {
        System.out.println("UserDaoImpl1.....");
    }
}
```

​		如果UserDao接口只有UserDaoImpl1这一个实现类，@Autowired注解就可以根据@Repository创建UserDaoImpl1类的对象给UserDao属性注入。

结果：@Autowired注解能够根据属性类型注入：

![image-20220316121256976](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316121256976.png)

​		如果UserDao接口有两个实现类UserDaoImpl1和UserDaoImpl2，并且两个实现类都使用注解创建了对象，那么，@Autowired就不知道应该用哪个对象给UserDao属性注入了。

​		**所以如果一个接口（类）有多个实现类(子类)时，要实现接口属性(父类属性)的注入，不能只使用@Autowired注解，还需要配合使用@Qualifier注解明确要注入哪个实现类(子类)的对象。**

实例：在UserService类的@Autowired注解下配和@Qualifier注解使用

```java
import com.spring.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    // @Autowired标记在需要注入的属性上面，@Autowired根据要注入的属性类型进行注入
    @Autowired
    @Qualifier( value = "userDaoImpl2")//根据创建对象的名字找到value，value表示某个用注解创建出来的对象名字
    private UserDao dao;//@Autowired找到UserDao类型的对象进行注入
    public void print(){
        System.out.println("service");
        dao.print();
    }
}
```

实现类1：

```java
import org.springframework.stereotype.Repository;

@Repository//不写value默认创建userDaoImpl1这个名字的对象
public class UserDaoImpl1 implements UserDao{
    @Override
    public void print() {
        System.out.println("UserDaoImpl1.....");
    }
}
```

实现类2：

```java
import org.springframework.stereotype.Repository;

@Repository//不写value默认创建userDaoImpl2这个名字的对象
public class UserDaoImpl2 implements UserDao{
    @Override
    public void print() {
        System.out.println("UserDaoImpl2");
    }
}
```

测试：

```java
@Test
public void test3(){
    ApplicationContext context=new ClassPathXmlApplicationContext("bean1.xml");
    UserService userService = context.getBean("userService", UserService.class);
    userService.print();
}
```

结果：找到了实现类2的对象并注入：

![image-20220316122436417](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316122436417.png)

### @Resource注解

@Resource的功能更加齐全，既可以根据属性类型来确定注入的值，也可以根据属性名确定注入的值。

实例：

```java
import com.spring.dao.UserDao;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;

@Service
public class UserService {
    //@Resource不加name属性表示根据属性类型注入，有name表示根据属性名注入
   @Resource(name = "userDaoImpl2")//现在要注入名字为userDaoImpl2的对象
    private UserDao dao;//@Autowired找到UserDao类型的对象进行注入
    public void print(){
        System.out.println("service");
        dao.print();
    }
}
```

UserDaoImpl2实现类，生成userDaoImpl2对象。

```java
import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl2 implements UserDao{
    @Override
    public void print() {
        System.out.println("UserDaoImpl2");
    }
}
```

结果：

![image-20220316132910181](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316132910181.png)

**注意：@Resource是javax包下的注解，其他三个都是spring包下的注解，所以不推荐使用@Resource。**

### @Value注解

前面三个注解都是给对象属性注入对象的，而@Value可以给普通属性注入值。

例如：

```java
import com.spring.dao.UserDao;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;


@Service
public class UserService {
    @Value("张三")
    private String name;
    public void print(){
        System.out.println("名字: "+name);
    }
}
```

测试：

```java
    @Test
    public void test3(){
        ApplicationContext context=new ClassPathXmlApplicationContext("bean1.xml");
        UserService userService = context.getBean("userService", UserService.class);
        userService.print();
    }
}
```

结果：

![image-20220316133500615](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316133500615.png)

### 完全注解开发

使用注解编写一个配置类来代替xml配置文件。

#### 创建配置类

替代xml配置文件扫描注解工作

```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
//创建配置类，替代Xml
@Configuration
@ComponentScan(basePackages = {"com.spring"})//@ComponentScan替代了xml的注解扫描
public class SpringConfig {
}
```

测试：

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;


@Service
public class UserService {
    @Value("张三")
    private String name;
    public void print(){
        System.out.println("名字: "+name);
    }
}
```

```java
@Test
public void test4(){
    ApplicationContext context=new AnnotationConfigApplicationContext(SpringConfig.class);//加载配置类
    UserService userService = context.getBean("userService", UserService.class);
    userService.print();
}
```

结果：和之前用xml配置文件一样

![image-20220316135226447](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316135226447.png)

**完全注解开发是SpringBoot要用到的**

### ---------------------------------------IOC------------完结-------------------------------------

## AOP

#### AOP简介

​		面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使地业务逻辑各个部分的耦合度降低，提高程序的可重用性，也提高了开发效率。**也就是说AOP可以不通过修改主干代码，来实现对主干代码功能的添加。**

**举例**：我们可以通过登录代码来举例

​	当登录成功时，区分时普通用户登录成功还是管理员登录成功（普通用户登录成功跳转页面和管理员不一样），我们可以使用AOP在主干代码上加入权限判断模块，用来判断是普通用户还是管理员。当不需要这个功能时，我们也可以撤销这个模块，也不会影响主干代码。

![image-20220316143550764](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316143550764.png)

### AOP底层原理

**AOP底层使用了动态代理**

动态代理有分两种

1、有接口的时候，用JDK动态代理

2、没有接口，有类时，用CGLIB动态代理

#### JDK动态代理

创建接口的实现类代理对象（不是new出来的）,用该对象来增强接口实现类的功能。

![image-20220316170712619](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316170712619.png)

#### CGLIB动态代理

创建当前类的子类代理对象（不是new出来的）,用该对象来增强子类的功能。

![image-20220316171149763](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316171149763.png)

### JDK动态代理实例(重要)

​	JDK动态代理的动态性体现在了Proxy.newProxyInstance（）方法上，当传入不同的被代理类对象，就可以为其创建相应的代理对象。

![image-20220316221031608](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316221031608.png)

#### 代码：

**UserDao接口：**

```java
public interface UserDao {
    int add(int a,int b);
    void print();
}
```

**UserDaoImpl实现类(被代理类)**

```java
public class UserDaoImpl implements UserDao{
    @Override
    public int add(int a, int b) {
        return a+b;
    }

    @Override
    public void print() {
        System.out.println("哈哈哈");
    }
}
```

**JDKProxy(JDK代理类)：**

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

//JDK代理
public class JDKProxy {
    //该方法生成并返回代理对象，参数为被代理类对象
    public static Object getProxy(Object obj){
        MyInvocationHandler handler = new MyInvocationHandler(obj);
        //返回被代理类Object的代理对象，参数1为被代理类的加载器，参数2为代理对象和被代理类的共同接口，参数3为实现代理对象和被代理类调用同名方法的接口实现类
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);
    }
//测试使用代理对象调用被代理类的方法
    public static void main(String[] args) {
        //创建被代理类UserDaoImpl的代理对象
        UserDao proxy = (UserDao) JDKProxy.getProxy(new UserDaoImpl());
        System.out.println(proxy.add(1, 2));
        proxy.print();
    }
}//该接口的实现类实现代理对象和被代理类对象调用同一个函数
class MyInvocationHandler implements InvocationHandler {
    //使用构造方法传入被代理类的对象
        Object object;
    MyInvocationHandler(Object obj){
        this.object=obj;
    }
    @Override
    //当代理对象调用某方法时，就会自动调用下面的invoke方法，并把调用的方法作为Method实参传进去,就可以实现代理类调用和被代理类的同方法了。
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        UserUtils util = new UserUtils();
        //加上通用的增强方法1
        util.method1();
        //调用被代理类的的方法
        Object returnValue = method.invoke(object, args);
        //加上通用的增强方法2
        util.method2();
        //返回被代理类的的方法的值
        return returnValue;
    }
}
```

**通用方法类**

```java
//封装通用的方法的类
public class UserUtils {
    public void method1(){
        System.out.println("通用方法1");
    }
    public void method2(){
        System.out.println("通用方法2");
    }
}
```

**加上通用方法后测试：**

![image-20220316221435237](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220316221435237.png)

### AOP操作的四个术语

#### 1、连接点

类中可以被增强的方法，就可以被成为连接点

#### 2、切入点

类中实际被增强的方法，成为切入点

#### 3、通知（增强）

增强的逻辑部分就是通知

通知可分为4种：

1、前置通知（放在方法前的通知）  @Before

2、后置通知（放在方法后的通知）  @AfterReturning

3、环绕通知（放在方法前后的通知）  @Around

4、异常通知（像try catch 的通知）  @AfterThrowing

5、最终通知（像finall的通知） @After

#### 4、切面

把通知加到切入点的动作（过程）称为切面。

### AspectJ框架

**AspectJ是一个独立于Spring框架和AOP框架的一个框架，AspectJ配合Spring来实现AOP操作。**

基于AspectJ实现AOP操作有两种方式

1、Xml

2、注解

**切入点表达式：**

execution(\[权限修饰符]\[返回类型]\[类全路径]\[方法名称][(参数列表)])

权限修饰符可省略：

实例1：对UserDao的print方法进行增强

权限修饰符可省略，返回值类型可以通过*代替，表示所有返回值类型。

execution(*com.spring.dao.UserDao.print(..))

实例2：对UserDao的所有方法进行增强

可以用*代替表示所有方法。

execution(*com.spring.dao.UserDao.\*(..))

实例3：对com.spring.dao包下的所有类的所有方法进行增强

execution(*com.spring.dao.\*.\*(..))

### 使用AspectJ注解实现AOP操作实例

**步骤：**

1、给被代理类和封装通知方法的类加上注解创建对象

2、在配置文件加上扫描注解

3、在代理类上加上@Aspect注解创建代理对象

4、在配置文件加上\<aop:aspectj-autoproxy>\</aop:aspectj-autoproxy>，找到@Aspect创建代理对象

5、在增强的方法上加上所需的通知注解，并配置好需要加强的方法。

6、测试

#### User类(被代理类)

uer类有需要增强的方法print()

```java
@Component(value = "user")//创建user对象
public class User {
    public void print(){
        System.out.println("原方法");
    }
}
```

#### UserProxy代理类(封装增强方法类)

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

//生成代理和增强方法类
@Component
@Aspect
public class UserProxy {
    @Before(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void before(){
        System.out.println("前置通知");
    }
    @After(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void after(){
        System.out.println("最终通知");
    }
    @AfterReturning(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void afterReturning(){
        System.out.println("后置通知");
    }
    @AfterThrowing(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void afterThrowing(){
        System.out.println("异常通知");
    }
    @Around(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void around(ProceedingJoinPoint point) throws Throwable {
        System.out.println("环绕通知前部分");
        point.proceed();
        System.out.println("环绕通知后部分");
    }
}
```

#### 配置文件

添加注解扫描和创建代理对象配置

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--    开启扫描-->
    <context:component-scan base-package="com.aopTest.aopanno"></context:component-scan>
    <!--    找到Aspect注解，创建代理对象-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

</beans>
```

测试：

```java
@Test
public void  AnnoTest(){
    ApplicationContext context=new ClassPathXmlApplicationContext("bean1.xml");
    User user = context.getBean("user", User.class);
    user.print();
}
```

正常测试结果：

![image-20220317140702117](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220317140702117.png)

在需要增强的方法中加入异常后测试：

```java
import org.springframework.stereotype.Component;

@Component(value = "user")
public class User {
    public void print(){
        System.out.println("原方法");
        int i=1/0;
    }
}
```

![image-20220317140955439](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220317140955439.png)

从结果上看：@After（最终通知）无论是正常运行还是异常都会执行，就像finall， @AfterThrowing（异常通知）只会在出现异常才执行。 

### 公共切入点的提取和增强方法的优先级

我们可以使用 @Pointcut注解将公共切入点提取出来，然后 @Pointcut标记的方法名就可以替换切入点路径了。

@Order()注解可以设置增强方法的调用优先级，括号里的数值越小优先级越高（只对类标记有用）。

**UserProxy（增强方法类）**

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
//生成代理和增强方法类
@Component
@Aspect
@Order(3)
public class UserProxy {
    //提取公共切入点
    @Pointcut(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void getCommPoint(){

    }
    @Before(value = "getCommPoint()")//将提取出来的切入点方法名作为value
    public void before(){
        System.out.println("前置通知");
    }
    @After(value = "getCommPoint()")
    public void after(){
        System.out.println("最终通知");
    }
    @AfterReturning(value = "getCommPoint()")
    public void afterReturning(){
        System.out.println("后置通知");
    }
    @AfterThrowing(value = "getCommPoint()")
    public void afterThrowing(){
        System.out.println("异常通知");
    }
    @Around(value = "getCommPoint()")
    public void around(ProceedingJoinPoint point) throws Throwable {
        System.out.println("环绕通知前部分");
        point.proceed();
        System.out.println("环绕通知后部分");
    }
}
```

**另一个增强方法类：**

```java
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Aspect
@Order(1)//优先级
public class OtherProxy {
    @Pointcut(value = "execution(* com.aopTest.aopanno.User.print(..))")
    public void getCommPoint(){

    }
    @Before(value = "getCommPoint()")
    public void otherBefore(){
        System.out.println("其他类的前置通知");
    }
    @AfterReturning(value = "getCommPoint()")
    public void otherAfterReturning(){
        System.out.println("其他类的后置通知");
    }

}
```

测试结果：优先级高的增强方法先被调用，最后结束。

![image-20220317144003045](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220317144003045.png)

### 使用AspectJXML实现AOP操作实例（了解）

步骤：

1、使用Bean创建增强方法类和被增强方法类对象

2、配置aop，先配置切入点id，和切入点方法路径，再配置切面，设置通知类型和切入点。

![image-20220317150617825](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220317150617825.png)

### ————————————AOP——————完结———————————

### JDBCTemplate

JDBCTemplate是Spring对JDBC进行封装对象，简化了数据库操作。

JDBCTemplate和之前JDBC写的Basedao差不多，通过反射动态实现了基本的增删查改操作。

**接下来用Book书城的增删查改实例来体现JDBCTemplate**

#### JDBCTemplate的准备

**创建BookDao接口和实现类BookDaoImpl**

**BookDao接口：**

```java
import com.JDBCTemplate.pojo.Book;

public interface BookDao {
    public int add(Book book);
}
```

**BookDaoImpl：**

```java
import com.JDBCTemplate.pojo.Book;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
@Repository//使用注解来创建 BookDaoImpl对象
public class BookDaoImpl implements BookDao {
    @Autowired//注入由配置文件的Bean创建的JdbcTemplate对象
    private JdbcTemplate jdbcTemplate;

    @Override
    public int add(Book book) {//调用jdbcTemplate对象的update实现方法来创建add()方法
       String sql="insert into t_book values(?,?,?) ";
       return  jdbcTemplate.update(sql,null,book.getName(),book.getPrice());
    }
}
```

**BookService**

```java
import com.JDBCTemplate.dao.BookDao;
import com.JDBCTemplate.pojo.Book;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
@Service
public class BookService {
    @Autowired//注入实现类对象bookDaoImpl，多态
    private BookDao bookDao;
    public  int addBook(Book book){//实现添加图书方法。
       return bookDao.add(book);
    }
}
```

配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
<!--配置Druid连接池-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close">
        <property name="url" value="jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC" />
        <property name="username" value="root" />
        <property name="password" value="123456Hh" />
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
    </bean>
<!--    创建JdbcTemplate对象，并给JdbcTemplate对象注入连接池资源-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <context:component-scan base-package="com.JDBCTemplate"></context:component-scan>
</beans>
```

测试：

```java
@Test
public void  test(){
    //读取配置文件
    ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
    //获取由注解创建的并注入BookDaoImpl对象的BookService对象。
    BookService bookService = context.getBean("bookService", BookService.class);
    bookService.addBook(new Book(1, "西游记", 24));
}
```

#### JDBCTemplate的更多应用

**BookService**

```java
import com.JDBCTemplate.dao.BookDao;
import com.JDBCTemplate.pojo.Book;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class BookService {
    @Autowired
    private BookDao bookDao;
    //添加图书
    public  int addBook(Book book){
       return bookDao.add(book);
    }
    //修改图书
    public  int updateBook(Book book){
        return bookDao.update(book);
    }
    //删除图书
    public int deleteBook(Integer id){
        return bookDao.delete(id);
    }
    //查询图书总数
    public void queryCount(){
        System.out.println(bookDao.queryCount());
    }
    //根据图书名字查询图书信息
    public void queryBookById(Integer id){
        System.out.println(bookDao.queryBookById(id));
    }
    //查询所有图书
    public void queryBookByAll(){
        System.out.println(bookDao.queryBookByAll());
    }
    //将图书信息保存到数组，再保存到List集合，实现批量添加图书
    public void batchAdd(List<Object[]> list){
        System.out.println(Arrays.toString(bookDao.batchAdd(list)));
    }//将图书信息保存到数组，ID放在最后，再保存到List集合，实现批量添加图书
    public void batchUpdate(List<Object[]> list){
        System.out.println(Arrays.toString(bookDao.batchUpdate(list)));
    }//将图书信ID保存到数组，再保存到List集合，实现批量删除图书
    public void batchDelete(List<Object[]> list){
        System.out.println(Arrays.toString(bookDao.batchDelete(list)));
    }
}
```

**BookDao**

```java
import com.JDBCTemplate.pojo.Book;

import java.util.Arrays;
import java.util.List;

public interface BookDao {
    public int add(Book book);
    public int update(Book book);
    public int delete(Integer id);
    public  int queryCount();
    public Book queryBookById(Integer id);
    public  List<Book> queryBookByAll();
    public int [] batchAdd(List<Object[]> list);
    public int [] batchUpdate(List<Object[]> list);
    public int [] batchDelete(List<Object[]> list);
}
```

**BookDaoImpl**（实现类）

```java
import com.JDBCTemplate.pojo.Book;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int add(Book book) {
       String sql="insert into t_book values(?,?,?) ";
       return  jdbcTemplate.update(sql,null,book.getName(),book.getPrice());
    }
    @Override
    public int update(Book book){
        String sql="update t_book set name=?, price=? where id=?";
        return jdbcTemplate.update(sql,book.getName(),book.getPrice(),book.getId());
    }
    @Override
    public int delete(Integer id){
        String sql="delete from t_book where id=?";
        return jdbcTemplate.update(sql,id);
    }
    @Override
    public  int queryCount(){
        String sql="select count(*) from t_book";
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
        return count;
    }
    @Override
    public  Book queryBookById(Integer id){
        String sql="select id,name,price from t_book where id=?";
        return jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper<Book>(Book.class),id);
    }
    @Override
    public  List<Book> queryBookByAll(){
        String sql="select id,name,price from t_book";
        return jdbcTemplate.query(sql,new BeanPropertyRowMapper<Book>(Book.class));
    }
    @Override
    public int[] batchAdd(List<Object[]> list){
        String sql="insert into t_book values(?,?,?)";
        //遍历list然后一行一行的添加，添加一次返回一个1
        int[] ints = jdbcTemplate.batchUpdate(sql,list);
        return ints;//返回改动的次数
    }

    @Override
    public int[] batchUpdate(List<Object[]> list) {
        String sql="update t_book set name=?,price=? where id=?";
        //遍历list然后一行一行的更新，添加一次返回一个1
        int[] ints = jdbcTemplate.batchUpdate(sql,list);
        return ints;//返回改动的次数
    }

    @Override
    public int[] batchDelete(List<Object[]> list) {
        String sql="delete from t_book where id=?";
        //遍历list然后一行一行的删除，添加一次返回一个1
        int[] ints = jdbcTemplate.batchUpdate(sql,list);
        return ints;//返回改动的次数
    }
}
```

### Spring事务

**事务就是一组数据库操作，而且这几个操作要不都可以完成，要不就都不完成。**

**事务的特性**

1、原子性：事务不可分割，要不都成功，要不都失败

2、一致性：事务提交前后的数据完整性不会受到影响

3、隔离性：事务执行过程中不会受其他事务的影响。

4、永久性：事务提交后会保存到数据库上。

**事务一般添加在Service层里**

**spring进行事务管理操作一般有两种方式**

1、编程式事务管理（臃肿）

2、声明式事务管理（简便，开发中常用）

**声明式事务管理有两种方式**

1、基于xml配置文件

2、基于注解方式（首选）

**spring使用注解方式进行事务管理，底层运用到AOP，也就是说AOP的主要应用场景就是事务管理**

**sping为事务管理提供了API，叫事务管理器（接口），它也许多实现类，根据不同的框架使用不同的实现类**

**基于连接池资源和 JdbcTemplate我们就使用DataSourceTransactionManager事务管理**

#### 声明式事务管理(注解方式)实例



**下面就以银行转账的实例来体现事务注解的作用**

UserDao接口

接口有两个方法，加钱和减钱方法。

```java
public interface UserDao {
    public  void  addMoney();
    public  void  subMoney();
}
```

UserDao接口实现类UserDaoImpl 

使用注解注入jdbcTemplate对象，实现类加钱和减钱的方法

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao{
    @Autowired
    JdbcTemplate jdbcTemplate;
    @Override
    public void addMoney() {
        String sql="update t_account set money=money+? where id=?";
        jdbcTemplate.update(sql,100,1);
    }

    @Override
    public void subMoney() {
        String sql="update t_account set money=money-? where id=?";
        jdbcTemplate.update(sql,100,2);
    }
}
```

UserService（业务层）：在类上加上事务注解@Transactional

**@Transactional事务注解标记在类上，就把整个类的所有操作都变成事务**

**@Transactional事务注解标记在方法上，就只把这个操作方法变成事务。**

```java
import com.JDBCTemplate.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class UserService {
    @Autowired
    private UserDao userDao;
    public void  accountMoney(){
        userDao.subMoney();
        int i=1/0;
        userDao.addMoney();
    }

}
```

Xml配置文件

1、先加上事务的名称空间tx。

xmlns:tx="http://www.springframework.org/schema/tx"

 http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd

2、将之前的连接池资源dataSource注入DataSourceTransactionManager事务管理实现类transactionManager。

3、开启事务注解

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
<!--配置Druid连接池-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close">
        <property name="url" value="jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC" />
        <property name="username" value="root" />
        <property name="password" value="123456Hh" />
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
    </bean>
<!--    给JdbcTemplate对象注入连接池资源-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <context:component-scan base-package="com.JDBCTemplate"></context:component-scan>
<!--   创建事务管理DataSourceTransactionManager实现类对象-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
<!--    开启事务注解，根据事务注解位置创建事务对象-->
    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
</beans>
```

异常测试：

**![image-20220318152109611](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318152109611.png)**

**结果：出现异常，事务不会提交**

### @Transactional注解的参数介绍

#### 一、事务的传播行为（propagation）

事务的传播行为就是当一个事务方法调用另一个事务方法（操作）时，被调用的事务方法会做出不同的行为（加入或者自己建事务等）。

**Spring定义了七种传播行为：**

![image-20220318120428816](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318120428816.png)

常用的事务传播行为有两个：

**1、PROPAGATION_REQUIRED**

**2、PROPAGATION_REQUIRED_NEW**

#### PROPAGATION_REQUIRED介绍

有两个事务方法methodA，methodB。

```java
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

public class ShiWu {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA(){
        methodB();
        //事务操作
    }
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB(){
        //事务操作
    }
    public void test(){//单独调用事务方法
        //methodA();
        methodB();
    }
}
```

​	当test单独调用事务方法B时，事务方法B知道test()方法不是事务方法，就会为自己开辟一个新的事务。

​	当test单独调用事务方法A时，事务方法A知道test()方法不是事务方法，就会为自己开辟一个新的事务，然后执行到 methodB()时， 事务方法B知道事务方法A是事务方法，就加入到事务方法A开辟的事务中，一起提交或一起回滚，**B加入到A事务中的行为就是事务传播行为**。

![image-20220318123806999](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318123806999.png)

#### PROPAGATION_REQUIRED介绍

```java
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

public class ShiWu {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodA(){
        methodB();
        //事务操作
    }
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB(){
        //事务操作
    }
    public void test(){
        methodA();
    }
}
```

​	当test单独调用事务方法B时，事务方法B知道test()方法不是事务方法，就会为自己开辟一个新的事务。

​	当test单独调用事务方法A时，事务方法A知道test()方法不是事务方法，就会为自己开辟一个新的事务，然后执行到 methodB()时， 事务方法B知道事务方法A是事务方法，就会将方法A的事务挂起，先执行自己的事务，直到自己的事务提交，才恢复到A的事务，一起提交或一起回滚。

![image-20220318123821819](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318123821819.png)

#### 二、隔离级别

#### 常出现的问题

**脏读：**对于两个事务T1,T2，T1正在读取一段数据，T2正好也在更新这一段数据但没提交，被没有提交的T1读到了，这时，如果T2回滚，T1读取到的新数据就没有意义了。

**不可重复读：**对于T1，T2两个事务，T1T2同时操作同一份数据，T2更新了一些数据并提交，T1再去重复读取，数据就发生了变化，即在同一个事务中不同时间里读同一份数据，结果不同。

**幻读**：对于T1，T2两个事务，T1正在操作一段数据，T2在这段数据添加了一行并提交，T1操作时就会发现这一段数据又多出了一条数据。

#### 四种隔离级别

针对数据看并发问题，数据库提供了四种隔离级别。

1、READ UNCOMMITTED（读未提交数据）

三种并发问题都没解决

2、READ COMMITED(读已提交数据)

解决了脏读问题

3、REPEATEABLE READ(可重复读)

解决和脏读和不可重复读问题。

4、SERIALIZABLE(串行化)

解决了脏读，不可重复读，和幻读问题

这四种隔离级别越往下数据一致性越好，但是并发性越差

#### 三、超时时间（timeout）

超时时间设置事务要在一定时间内要提交，不然就会回滚，设置时间以秒做单位。

超时时间默认值是-1，默认事务提交没有时间限制。

#### 四、是否只读（readOnly）

设置事务是否只能执行读操作，默认是false，就是还可以做其他操作。

#### 五、回滚（rollbackForClassName）

可以设置哪些异常需要回滚

#### 六、不回滚（noRollbackForClassName）

可以设置哪些异常不需要回滚

### 使用xml实现Spring声明事务管理

还是使用上面银行转账的实例进行xml配置事务

​	**xml实现Spring声明事务管理是基于AOP操作的，即将Spring提供的事务管理器实现类当场AOP操作的通知，再将通知放到切入点，就实现了从普通方法变成事务方法的增强。**

步骤：

1、配置事务方法通知

2、配置切面

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
                          http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置Druid连接池-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close">
        <property name="url" value="jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC" />
        <property name="username" value="root" />
        <property name="password" value="123456Hh" />
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
    </bean>
    <!--    给JdbcTemplate对象注入连接池资源-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <context:component-scan base-package="com.JDBCTemplate"></context:component-scan>
    <!--   创建事务管理DataSourceTransactionManager实现类对象-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
<!--    将事务方法变为通知-->
    <tx:advice id="txAdvice">
<!--        配置事务-->
        <tx:attributes>
<!--            事务作用在转账方法上，即事务注解相关参数-->
            <tx:method name="accountMoney" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>
<!--    配置切入点切面-->
    <aop:config>
<!--        配置切入点-->
        <aop:pointcut id="pt" expression="execution(* com.JDBCTemplate.service.UserService.*(..))"/>
<!--        配置切面,设置通知名和切入点名，将事务方法，加到切点上-->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"></aop:advisor>
    </aop:config>
</beans>
```

### 用全注解实现Spring声明事务管理

用全注解实现Spring声明事务管理就是将用注解实现Spring声明事务管理的xml配置文件中的配置连接池、给JdbcTemplate对象注入连接池资源、给事务管理实现类注入连接池资源、开启事务注解全部注解配置类实现。

1、将XML配置文件中的Bean标签创建对象全部用@Bean注解代替。

@Bean下的方法实现对象的实例化并返回对象，对象会保存到IOC容器中。

2、将XML中不是Bean标签的直接放在类外注解

```java
import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration//创建配置类
@ComponentScan(basePackages = "com.JDBCTemplate")//开启注解扫描
@EnableTransactionManagement//开启事务
public class TxConfig {
    //获取Druid连接池资源
    @Bean
    public DruidDataSource getDataSource(){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC");
        dataSource.setUsername("root");
        dataSource.setPassword("123456Hh");
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return dataSource;//将dataSource放到IOC容器里
    }
    //给JdbcTemplate对象注入连接池资源
    @Bean
    public JdbcTemplate getJdbcTemplate(DruidDataSource dataSource){//直接通过IOC容器获取dataSource。
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }
    //给事务管理实现类注入连接池资源
    @Bean
    public DataSourceTransactionManager getTransactionManager(DruidDataSource dataSource){
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }

}
```

### Spring5框架新特性

#### 整合日志框架

**第一步：引入下列依赖：**

![image-20220318174919680](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318174919680.png)

**第二步：编写日志xml配置文件**

**文件名固定为log4j2.xml**

主要设置日志级别以及优先级排序：高层次的的日志可以将低层次的日志信息输出。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出-->
<configuration status="DEBUG">
    <!--先定义所有的appender-->
    <appenders>
        <!--输出日志信息到控制台-->
        <console name="Console" target="SYSTEM_OUT">
            <!--控制日志输出的格式-->
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </console>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出-->
    <loggers>
        <root level="info">
            <appender-ref ref="Console"/>
        </root>
    </loggers>
</configuration>
```



**第三步:运行测试：**

随便运行一个测试:

![image-20220318175527677](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220318175527677.png)
