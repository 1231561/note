# 自定义注解

自定义注解一般要加上四个JDK元注解

元注解用于修饰其他的注解(纪委：管干部的干部)
 **@Retention：定义注解的保留策略**
      @Retention(RetentionPolicy.SOURCE)             //注解仅存在于源码中，在class字节码文件中不包含
      @Retention(RetentionPolicy.CLASS)              //默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，
      @Retention(RetentionPolicy.RUNTIME)            //注解会在class字节码文件中存在，在运行时可以通过反射获取到

**@Target：指定被修饰的Annotation可以放置的位置(被修饰的目标)**
      @Target(ElementType.TYPE)                      //接口、类
      @Target(ElementType.FIELD)                     //属性
      @Target(ElementType.METHOD)                    //方法
      @Target(ElementType.PARAMETER)                 //方法参数
      @Target(ElementType.CONSTRUCTOR)               //构造函数
      @Target(ElementType.LOCAL_VARIABLE)            //局部变量
      @Target(ElementType.ANNOTATION_TYPE)           //注解
      @Target(ElementType.PACKAGE)                   //包 
     

  注：可以指定多个位置，例如：

 @Target({ElementType.METHOD, ElementType.TYPE})，也就是此注解可以在方法和类上面使用

 **@Inherited：指定被修饰的Annotation将具有继承性** 

**@Documented：指定被修饰的该Annotation可以被javadoc工具提取成文档.**

### 注解分类
  根据Annotation是否包含成员变量,可以把Annotation分为两类: 

**1、标记Annotation:** 

没有成员变量的Annotation; 这种Annotation仅利用自身的存在与否来提供信息      

**2 、元数据Annotation:** 
包含成员变量的Annotation；他们可以接受（或提供）更多的元数据。

## 实例：

**自定义注解：**

自定义注解的@Retention注解一般使用RetentionPolicy.RUNTIME，可在运行时得到注解信息。

```java
import java.lang.annotation.*;

@Documented
@Inherited
@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    //注解的属性可以有默认值
    String value() default "";
    String message() default "我是一个注解";
}
```

**使用注解：**

```java
import java.lang.annotation.Annotation;
//注解不设置属性值则使用默认值
@MyAnnotation(value = "自定义注解")
public class AnnotationTest {
    public static void main(String[] args) {
        Annotation[] annotations = AnnotationTest.class.getAnnotations();
        System.out.println(annotations[0]);
    }
}
```

![image-20220722115234184](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220722115234184.png)