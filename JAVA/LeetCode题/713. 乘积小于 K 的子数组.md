#### [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

难度中等545收藏分享切换为英文接收动态反馈

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。

 

**示例 1：**

```
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
```

**示例 2：**

```
输入：nums = [1,2,3], k = 0
输出：0
```

 

**提示:** 

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`

## 思路：滑动窗口

​		窗口左右边界初始为0，左边界先不动，右边界向右移动。计算左右边界之间的乘积小于 `k` 的连续子数组的个数，直到的连续子数组的乘积大于等于k，左边界向右移动，接着计算左右边界之间的乘积小于 `k` 的连续子数组的个数。

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int left = 0;
        int res = 1;
        int son = 0;
        for(int right = 0; right < nums.length; right++){
            res *= nums[right];//计算窗口左右边界之间的的连续子数组乘积
            while(left <= right && res >= k){//当连续子数组乘积大于等于k或左边界小于右边界
                res /= nums[left];//左边界右移，乘积自然要除于左边界的数值
                left++;
            }
            
            son += right - left + 1;//将窗口里的连续子数组的个数累加，相当于累加以nums[right]为末尾的连续子数组。如nums = [10,5,2,6], k = 100,10的续子数组为[10]，则10，5的续子数组不能再包含10了，所以只能是[5]、[10,5]两个以5为末尾的连续子数组。
        }
        return son;
    }
}
```