# 电脑商城实战项目

### 一：准备工作

#### 测试连接

**通用数据库连接池配置：**

application.properties里配置：

```java
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/store?serverTimezone=UTC&useUnicode=true&zeroDateTimeBehavior=convertToNull&autoReconnect=true&characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=123456Hh
```

**测试类测试数据库连接：**

![image-20220520152524352](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520152524352.png)

**测试结果：**

自动注入了springboot默认整合的数据库连接池资源：**Hikari**

![image-20220520152732288](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520152732288.png)

#### 测试静态资源

**1、将静态资源文件拷贝到static目录下**

注意：idea对于js代码等静态资源的兼容性较差，js代码有时候不能生效

解决方案：

1、idea缓存清理

2、clear-install

3、rebuild重新构建项目

4、重启idea

**2、测试访问静态资源**

访问static目录下的404页面

**static等资源目录不用显示的去访问，直接显示的访问static目录下的文件静态文件即可**

![image-20220520154108878](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520154108878.png)

**注意，上面提到idea对于等静态资源的兼容性较差，第一次部署访问静态资源可能会访问不到。**

**解决方法：项目的生命周期先clear后install即可**

![image-20220520154400515](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520154400515.png)

**测试成功：**

![image-20220520154502505](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520154502505.png)

### 二、用户注册

**1、在store数据库创建user表**

使用COMMENT关键字可以在后面加注释

![image-20220520181931453](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520181931453.png)

**2、抽取多张表公共字段，创建对应实体类基类**

​	**springboot遵循约定大于配置规则,如果实体类的对象的属性和数据库表的字段对应，则可以使用字段值帮属性进行初始化**

**创建实体类的get、set、equals、hashCode,toString方法**

equals方法用于对对象内容进行比较，hashCode进行地址的输出,toString方法输出对象的属性值。

**实体类需要实现Serializable接口，实现序列化，方便数据的存储和转换**

**实体类属性需要使用包装类定义，方便调用包装类方法**

![image-20220520184429804](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520184429804.png)

**3、创建user实体类**

![image-20220520185258925](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220520185258925.png)

#### (一) 用户注册：持久层（mapper、dao）

主要使用mybatis操作数据库

**1、规划需要执行的SQL语句**

1、注册用户实际是在数据库做添加操作

insert into t_user (username, password....) values (对应值)

2、注册用户时需要判断用户是否存在

select * form t_user where username=?

**2、设计对应的持久层接口和抽象方法**

根据上面的sql语句设计持久层接口和抽象方法

```java
public interface UserMapper {
    /**
     * 插入用户
     * @param user 用户对象数据
     * @return 插入了几条数据（影响的行数）
     */
    Integer insert(User user);

    /**
     * 根据用户名查找用户
     * @param username 用户名
     * @return 找到则返回用户对象，找不到返回null
     */
    User findById(String username);
}
```

**springboot启动类中加上Mapper扫描注解**

这样就不用再每个实体类上加上@Mapper，还可以减轻springboot的搜房负担

```java
@SpringBootApplication
//@MapperScan指定Mapper接口的路径，启动项目时自动加载路径下的Mapper接口
@MapperScan("com.hyh.cstore.mapper")
public class CStoreApplication {

    public static void main(String[] args) {
        SpringApplication.run(CStoreApplication.class, args);
    }

}
```

**3、定义mybatis的xml映射文件，映射持久层接口及方法**

namespace标签指定需要映射的接口的完整路径

当实体类属性与数据库表字段名字不相同时，使用使用resultMap标签指定映射规则(或者在mybatis的主配置文件加驼峰命名映射，或者给数据库表字段起和实体类属性一样的别名)

**resultMap的id属性名给sql标签使用**

useGeneratedKeys给自增的字段(一般是属性)自动添加值，keyProperty表示自增的字段名。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.cstore.mapper.UserMapper">
    <resultMap id="userMap" type="com.hyh.cstore.entity.User">
        <result column="is_delete" property="isDelete"></result>
        <result column="created_user" property="createdUser"></result>
        <result column="created_time" property="createdTime"></result>
        <result column="modified_user" property="modifiedUser"></result>
        <result column="modified_time" property="modifiedTime"></result>
    </resultMap>
    <insert id="insert" useGeneratedKeys="true" keyProperty="uid">
        INSERT INTO store.t_user(uid, username, password, salt, phone, email, gender, avatar, is_delete, created_user, created_time, modified_user, modified_time)
        VALUES (#{uid}, #{username}, #{password}, #{salt}, #{phone}, #{email}, #{gender}, #{avatar}, #{isDelete}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime})
    </insert>
    <select id="findById" resultMap="userMap">
        SELECT uid, username, password, salt, phone, email, gender, avatar, is_delete, created_user, created_time, modified_user, modified_time from store.t_user where username=#{username}
    </select>
</mapper>
```

**在application.properties配置文件注册mapper.xml文件,指定文件路径。**

```properties
mybatis.mapper-locations=classpath:mapper/*.xml
```

**测试持久层：**

```java
@SpringBootTest
public class MapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    void insert(){
        User user = new User();
        user.setUsername("张三");
        user.setPassword("123456");
        System.out.println(userMapper.insert(user));
    }
    @Test
    void select(){
        System.out.println(userMapper.findById("张三"));
    }
}
```

#### (二) 用户注册：业务层

**1、异常规划**

​		当用户名存在，无法正常注册，应该抛出用户名重复异常。为了统一管理异常，可以创建一个业务异常基类，以便将来自定义异常继承基类，扩展方法。

**创建异常包、创建异常基类**

```java
public class ServiceException extends RuntimeException{//继承运行时异常接口
    public ServiceException() {
        super();
    }

    public ServiceException(String message) {
        super(message);
    }

    public ServiceException(String message, Throwable cause) {
        super(message, cause);
    }

    public ServiceException(Throwable cause) {
        super(cause);
    }

    protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

**创建具体的业务部分出现的异常类，继承RuntimeException业务异常基类**

1、注册时用户名被占用时的异常：UsernameDuplicateException

```java
public class UsernameDuplicateException extends ServiceException{
    public UsernameDuplicateException() {
        super();
    }

    public UsernameDuplicateException(String message) {
        super(message);
    }

    public UsernameDuplicateException(String message, Throwable cause) {
        super(message, cause);
    }

    public UsernameDuplicateException(Throwable cause) {
        super(cause);
    }

    protected UsernameDuplicateException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

2、注册用户将用户数据插入数据库表时出现的异常： InsertException

```java
public class InsertException extends ServiceException{
    public InsertException() {
        super();
    }

    public InsertException(String message) {
        super(message);
    }

    public InsertException(String message, Throwable cause) {
        super(message, cause);
    }

    public InsertException(Throwable cause) {
        super(cause);
    }

    protected InsertException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

**2、创建业务的接口和抽象方法**

**创建用户业务接口和业务抽象方法**

注册用户业务方法：

```java
/**处理用户数据的业务层接口*/
public interface IUserService {
    /**
     * 用户注册
     * @param user 传入一个用户类
     */
    void reg(User user);
}
```

**创建建业务接口实现类包impl**

**创建业务接口实现类**

首先完成用户注册业务方法：

```java
@Service
public class UserServiceImpl implements IUserService {
    @Autowired
    UserMapper userMapper;
    @Override
    public void reg(User user) {
        User res = userMapper.findByName(user.getUsername());
        //用户名存在
        if(res != null){
            throw new UsernameDuplicateException("该用户名已存在");
        }
        //将注册用户必要的用户信息填充完整

        //使用md5算法给用户密码加密:加密形式:盐值+password+盐值三次加密
        String oldPassword = user.getPassword();
        String salt = UUID.randomUUID().toString().toUpperCase(Locale.ROOT);
        String md5Password = getMd5Password(oldPassword, salt);
        //保存加密后的密码
        user.setPassword(md5Password);
        //必须保存盐值，后面登录时需要根据数据库表里的盐值加密码验证登录
        user.setSalt(salt);

        //用户的注销状态
        user.setIsDelete(0);
        Date date = new Date();
        //四个用户注册日志
        user.setCreatedUser(user.getUsername());
        user.setModifiedUser(user.getUsername());
        user.setCreatedTime(date);
        user.setModifiedTime(date);
        Integer insert = userMapper.insert(user);
        //插入用户数据失败
        if(insert != 1){
            throw new InsertException("注册用户时出现了些问题");
        }
    }
    public String getMd5Password(String password, String salt){
        for(int i = 0; i < 3; i++){
            password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase();
        }
        return password;
    }

}
```

测试用户注册业务：

```java
@SpringBootTest
public class ServiceTest {
    @Autowired
    private IUserService service;
    @Test
    void reg(){
        try {
            User user = new User();
            user.setUsername("李四");
            user.setPassword("123456");
            service.reg(user);
            System.out.println("注册成功");
        } catch (ServiceException e) {//业务异常处理基类，实现多态
            //输出异常对象信息
            System.out.println(e.getClass().getName());
            System.out.println(e.getMessage());
        }
    }
}
```

测试成功：

![image-20220521152036281](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220521152036281.png)

#### (三) 用户注册：控制层层

**1、创建响应结果类，涉及状态码、状态描述信息、数据，将其封装在一个类中，将对象作为方法返回值返回到前端浏览器显示。**

```java
/**
 * Json格式数据响应结果集
 * @param <E> 响应的数据的类型
 */
public class JsonResult<E> implements Serializable {
    /** 状态码*/
    private Integer state;
    /** 描述信息*/
    private String message;
    /** 数据*/
    private E data;

    public JsonResult() {
    }

    public JsonResult(Integer state) {
        this.state = state;
    }
    /** 出现异常时调用此方法，获取异常信息*/
    public JsonResult(Throwable e) {
        this.message = e.getMessage();
    }

    public JsonResult(Integer state, E data) {
        this.state = state;
        this.data = data;
    }
}
```

**2.设计请求，并设计响应的方式**

```
请求路径:/users/reg
请求参数：User user
请求类型:POST
请求结果：JsonResult<Void>
```

**3、处理请求**

执行注册业务时，捕获用户注册时可能发生的异常。不同的异常对应不同的响应结果集(状态码、数据、响应信息不同)，不发生异常就返回200的响应结果集对象。

```java
@RestController//该注解是Controller+ResponseBody的结合
@RequestMapping("users")
public class UserController {
    @Autowired
    IUserService service;
    JsonResult<Void> result = new JsonResult<>();
    @RequestMapping("reg")
    public JsonResult<Void> reg(User user){
        try {
            service.reg(user);
            result.setState(200);
            result.setMessage("注册成功");
        } catch (UsernameDuplicateException e) {
            result.setState(4000);
            result.setMessage("用户名已被占用");
        }catch (InsertException e){
            result.setState(5000);
            result.setMessage("注册失败，请重新注册");
        }
        return result;
    }
}
```

**控制层的优化：**

创建一个控制层基类，创建一个返回响应结果集的方法

```java
public class BaseController {
    public static final Integer OK = 200;
    //该注解只处理ServiceExceptio自定义类型的异常，并映射到handleException方法
    @ExceptionHandler(ServiceException.class)
    public JsonResult<Void> handleException(Throwable e){
        JsonResult<Void> result = new JsonResult<>();
        if(e instanceof UsernameDuplicateException){
            result.setState(4000);
            result.setMessage(e.getMessage());
        }
        if(e instanceof InsertException){
            result.setState(5000);
            result.setMessage(e.getMessage());
        }
        return result;
    }

}
```

控制层子类继承控制层基类

```java
@RestController
@RequestMapping("users")
public class UserController extends BaseController{
    @Autowired
    IUserService service;
    @RequestMapping("reg")
    public JsonResult<Void> reg(User user){
        //出现异常并抛出ServiceException类型的异常后，调用父类的handleException方法，返回结果集
        service.reg(user);
        return new JsonResult<>(OK);//否则返回200的结果集·
    }
}

```

#### (四) 用户注册：前端页面

**通过发送ajax异步请求处理用户注册请求。**

![image-20220521211319690](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220521211319690.png)

在注册页面使用script标签编写js代码，绑定单击事件并发送ajax请求完成用户注册。

```java
<script>
   $("#btn-reg").click(function () {
      $.ajax({
          //请求地址
         url: "/users/reg",
          //请求类型
         type: "POST",
          //将表单的数据序列化,相当于 "username=tom&password=123456"
         data: $("#form-reg").serialize(),
         dataType: "JSON",
          //服务器接收请求后，如果正常响应,给回调函数success返回一个参数json.
         success: function (json) {
            if(json.state == 200){
               alert("注册成功")
            }else {
               alert("注册失败")
            }
         },
          //服务器接收请求后，如果未正常响应,给回调函数error返回一个参数xhr.
         error: function (xhr) {
            alert("注册时产生未知的错误")
         }
      })
   })
</script>
```

### 2、用户登录

#### 1、持久层

可以使用用户注册的持久层的查询用户的实现类方法。不必在新建一个用户登录的持久层。

#### 2、业务层

**1、规划异常**

创建用户不存在和密码错误的异常类，当出现这两个异常时，就抛出这两个类的异常对象。

```java
/** 用户数据不存在的异常 */
public class UserNotFoundException extends ServiceException {
    public UserNotFoundException() {
        super();
    }

    public UserNotFoundException(String message) {
        super(message);
    }

    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public UserNotFoundException(Throwable cause) {
        super(cause);
    }

    protected UserNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

```java
/** 密码验证失败的异常 */
public class PasswordNotMatchException extends ServiceException {
    public PasswordNotMatchException() {
        super();
    }

    public PasswordNotMatchException(String message) {
        super(message);
    }

    public PasswordNotMatchException(String message, Throwable cause) {
        super(message, cause);
    }

    public PasswordNotMatchException(Throwable cause) {
        super(cause);
    }

    protected PasswordNotMatchException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

**2、在用户接口添加用户登录抽象方法**

```java
/**
 * 用户登录
 * @param username 用户名
 * @param password 密码
 * @return user对象，即，登录成功后，供session使用
 */
User login(String username, String password);
```

**3、实现用户登录抽象方法**

```java
/** 用户登录业务*/
@Override
public User login(String username, String password) {
    User res = userMapper.findByName(username);
    if(res == null){
        throw new UserNotFoundException("当前用户不存在");
    }
    //检测用户注销状态
    Integer isDelete = res.getIsDelete();
    if(isDelete == 1){
        throw new UserNotFoundException("当前用户不存在");
    }
    //对输入的密码进行MD5三次加密，然后和原密码比较
    String userPassword = res.getPassword();
    String salt = res.getSalt();
    String logPassword = getMd5Password(password, salt);
    if(!userPassword.equals(logPassword)){
        throw new PasswordNotMatchException("密码错误");
    }
    //将必要(session需要展示到页面)的数据保存到user，其余用户数据为null，减小数据量，减轻浏览器负担。
    User user = new User();
    user.setUid(res.getUid());
    user.setUsername(res.getUsername());
    user.setAvatar(res.getAvatar());
    return user;
}
```

**4、测试**

```java
@Test
void login(){
    try {
        service.login("李四","123");
        System.out.println("登陆成功");
    } catch (ServiceException e) {
        System.out.println(e.getClass().getName());
        System.out.println(e.getMessage());
    }
}
```

#### 3、控制层

**1、处理异常**

​		当业务层用户登录抛出PasswordNotMatchException和UserNotFoundException异常对象时，需要控制层处理这两个异常，并返回给前端。即在BaseController类中集中处理异常的方法handleException，添加这两个异常的处理分支(4001、4002)。

```java
@ExceptionHandler(ServiceException.class)
public JsonResult<Void> handleException(Throwable e){
    JsonResult<Void> result = new JsonResult<>();
    if(e instanceof UsernameDuplicateException){
        result.setState(4000);
        result.setMessage(e.getMessage());
    }else if(e instanceof UserNotFoundException){
        result.setState(4001);
        result.setMessage(e.getMessage());
    }else if(e instanceof PasswordNotMatchException){
        result.setState(4002);
        result.setMessage(e.getMessage());
    }else if(e instanceof InsertException){
        result.setState(5000);
        result.setMessage(e.getMessage());
    }
    return result;
}
```

**2、设计请求**

设计用户发送给服务器的请求，设计控制层响应的结果集

```
请求路径：/users/login 
请求参数：String username, String password ，HttpSession session
请求类型：POST 
响应结果：JsonResult<User>
```

**3、处理请求**

1、在UserController类中添加用户请求处理及其相应结果

```java
@RequestMapping("login")
//泛型设置为User，表示data为user对象数据，返回JsonResult的实例给前端，包含状态码和user对象，和状态信息。
public JsonResult<User> logon(String username, String password){
    User user = service.login(username, password);
    //构造方法传递user对象的值及状态码
    return new JsonResult<>(OK,user);
}
```

2、测试请求处理及相应结果

![image-20220522144257661](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220522144257661.png)

**4、前端编写ajax请求**

```html
<script>
   $("#btn-login").click(function () {
      $.ajax({
         url: "/users/login",
         type: "POST",
         data: $("#form-login").serialize(),
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
               alert("登录成功")
               //跳转到首页
               location.href = "index.html"
            }else if(json.state == 4001) {
               alert(json.message)
            }
            else if(json.state == 4002) {
               alert(json.message)
            }
         },
         error: function (xhr) {
            alert("登录时遇到意外的错误" + xhr.message)
         }
      })
   })
</script>
```

**5、将uid和username保存到session对象中。**

**BaseController添加获取session对象中的uid和username.**

```java
protected final Integer getUidFromSession(HttpSession session){
    Integer uid = (Integer) session.getAttribute("uid");
    return uid;
}
protected final String getUsernameFromSession(HttpSession session){
    String username = (String) session.getAttribute("username");
    return username;
}
```

**UserController用户登录的方法加上seesion参数接收session对象。**

​		服务器在自动创建了一个全局的session对象(HttpSession的实现类对象)。springboot会将该全局session对象注入到带有HttpSession类型参数的控制器方法的session参数。

```java
@RequestMapping("login")
//泛型设置为User，表示data为user对象数据，返回JsonResult的实例给前端，包含状态码和user对象，和状态信息。
public JsonResult<User> login(String username, String password, HttpSession session){
    User user = service.login(username, password);
    session.setAttribute("uid", user.getUid());
    session.setAttribute("username", user.getUsername());
    System.out.println(getUidFromSession(session));
    System.out.println(getUsernameFromSession(session));
    //构造方法传递user对象的值及状态码
    return new JsonResult<>(OK,user);
}
```

#### 4、拦截器

设置一个拦截器，当用户没有登录，session中的uid和username都为null。这时，用户无法访问某些页面。

**1、创建登录拦截器**

重新preHandle方法制定拦截规则。返回false则拦截请求，该方法将在请求处理之前被调用。

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object uid = request.getSession().getAttribute("uid");
        if(uid == null){
            //重定向至登陆页面
            response.sendRedirect("/web/login.html");
            return false;
        }
        return true;
    }
}
```

**2、配置拦截器**

现WebMvcConfigurer接口的addInterceptors(添加拦截器方法)，指定拦截的资源路径。

```java
@Configuration
public class LoginInterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        LoginInterceptor loginInterceptor = new LoginInterceptor();
        //保存拦截器的白名单(不被拦截的页面)
        ArrayList<String> patterns = new ArrayList<>();
        patterns.add("/bootstraps3/**");
        patterns.add("/css/**");
        patterns.add("/images/**");
        patterns.add("/js/**");
        patterns.add("/web/login.html");
        patterns.add("/web/index.html");
        patterns.add("/web/product.html");
        patterns.add("/web/users.html");
        patterns.add("/users/login");
        patterns.add("/users/reg");
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**")//拦截所有页面
                .excludePathPatterns(patterns);//排除这些白名单不拦截
    }
}
```



### 3、修改密码

#### 持久层

**1、规划需要执行的SQL语句**

根据用户的uid修改用户的password值

```sql
update t_user set password=?,modified_user=?, modified_time=?  where uid=?
```

修改用户前，首先要查询用户是否存在，检测用户是否被标记注销，及检测用户的原密码是否输入正确。

```sql
select * from t_user where uid=?
```

**2、设计接口和抽象方法**

```java
/**
 * 通过uid修改密码，并更新修改人和修改时间信息
 * @param uid
 * @param password
 * @param modifiedUser
 * @param modifiedTime
 * @return 影响几条记录
 */
Integer updatePasswordByUid(Integer uid, String password, String modifiedUser, Date modifiedTime);

/**
 * 通过uid查找用户信息
 * @param uid
 * @return
 */
User findByUid(Integer uid);
```

**3、UserMapper映射**

```xml
<update id="updatePasswordByUid">
    UPDATE store.t_user SET password=#{password},modified_user=#{modifiedUser},modified_time=#{modifiedTime} WHERE uid=#{uid}
</update>
<select id="findByUid" resultMap="userMap">
    SELECT uid, username, password, salt, phone, email, gender, avatar, is_delete, created_user, created_time, modified_user, modified_time from store.t_user where uid=#{uid}
</select>
```

**4、测试**

```java
void modified(){
    System.out.println(userMapper.findByUid(2));
    System.out.println(userMapper.updatePasswordByUid(2, "654321", "李五", new Date()));
}
```

#### 业务层

**1、异常规划**

1、修改密码时，用户找不到(被管理员误删)

2、更新密码时，产生未知的异常(网络波动等)

创建更新密码异常类

```java
public class UpdateException extends ServiceException{
    public UpdateException() {
    }
```

**2、接口添加抽象方法**

```java
/**
 * 修改密码
 * @param uid 通过session对象获取
 * @param username 通过session对象获取
 * @param oldPassword 通过前端请求获取
 * @param newPassword 通过前端请求获取
 */
void changePassword(Integer uid, String username, String oldPassword, String newPassword);
```

**3、实现抽象方法**

```java
@Override
public void changePassword(Integer uid, String username, String oldPassword, String newPassword) {
    User res = userMapper.findByUid(uid);
    if(res == null){
        throw new UserNotFoundException("用户不存在");
    }
    if(res.getIsDelete() == 1){
        throw new UserNotFoundException("用户不存在");
    }
    //输入的原密码和数据库的原密码进行比较
    String salt = res.getSalt();
    String md5OldPassword = getMd5Password(oldPassword, salt);
    if(!res.getPassword().equals(md5OldPassword)){
        throw new PasswordNotMatchException("原密码错误");
    }
    //将新密码跟新原密码
    String md5NewPassword = getMd5Password(newPassword, salt);
    Integer integer = userMapper.updatePasswordByUid(uid, md5NewPassword, username, new Date());
    if(integer != 1){
        throw new UpdateException("修改密码时发生了未知错误");
    }
}
```

**4、测试**

```java
@Test
void changePassword(){
    service.changePassword(3,"王五","123456","654321");
}
```

#### 控制层

**1、处理异常**

在控制层基类的处理异常方法添加上用户修改密码可能出现的抛出的异常UpdateException。

```java
@ExceptionHandler(ServiceException.class)
public JsonResult<Void> handleException(Throwable e){
    JsonResult<Void> result = new JsonResult<>(e);
    if(e instanceof UsernameDuplicateException){
        result.setState(4000);
    }else if(e instanceof UserNotFoundException){
        result.setState(4001);
    }else if(e instanceof PasswordNotMatchException){
        result.setState(4002);
    }else if(e instanceof UpdateException){
        result.setState(4003);
    }else if(e instanceof InsertException){
        result.setState(5000);
    }
    return result;
}
```

**2、设计请求**

设计用户提交修改密码的表单发送的请求。

```
请求路径：/users/change_password 
请求参数：String oldPassword, String newPassword, HttpSession session 
请求类型：POST 
响应结果：JsonResult<Void>
```

**3、处理请求**

根据上面请求的设计，创建一个控制器方法，处理修改密码请求。

```java
/**
 * 修改密码控制器方法，参数名和前端的表单的name属性名一致。
 * @param oldPassword 原密码
 * @param newPassword 新密码
 * @param session 通过会话获取修改密码人的信息
 * @return 给前端返回结果集
 */
@RequestMapping("change_password")
public JsonResult<Void> changePassword(String oldPassword, String newPassword, HttpSession session){
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    service.changePassword(uid, username, oldPassword, newPassword);
    return new JsonResult<>(OK);
}
```

**4、测试：**

![image-20220523123642668](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220523123642668.png)

#### 前端页面

设计ajax请求，完成前端修改密码

```html
<script>
   $("#btn-change-password").click(function () {
      $.ajax({
         url: "/users/change_password",
         type: "POST",
         data: $("#form-change-password").serialize(),
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
               alert("密码修改成功")
               //跳转到首页
               location.href = "login.html"
            }else {
               alert("密码修改失败: " + json.message)
            }
         },
         error: function (xhr) {
            alert("登录时遇到意外的错误" + xhr.message)
         }
      })
   })
</script>
```

### 4、个人资料

#### 持久层

**1、规划SQL**

1、修改个人资料

```sql
UPDATE t_user SET phone=?, email=?, gender=?, modified_user=?, modified_time=? WHERE uid=?
```

2、打开个人资料页面(加载页面时)，会(自动)查询个人资料，并将资料自动写入个人资料，显示给用户。

该sql语句对应的方法已存在和mapper映射已存在。

```sql
SELECT * FROM t_user WHERE uid=?
```

**2、添加抽象方法以及mapper映射**

抽象方法

```java
/**
 * 修改用户信息
 * @param user 将user对象的属性传递给mapper.xml中sql语句的同名占位符
 * @return 影响行数
 */
Integer changeInfoByUid(User user);
```

mapper映射：user对象的属性传递给mapper.xml中sql语句的同名占位符(约定大于配置)

```xml
<update id="changeInfoByUid">
    UPDATE store.t_user
    SET
    <if test="phone != null">phone=#{phone},</if>
    <if test="email != null">email=#{email},</if>
    <if test="gender != null">gender=#{gender},</if>
        modified_time=#{modifiedTime},
        modified_user=#{modifiedUser}
    WHERE uid=#{uid}
</update>
```

单元测试：

```java
@Test
public void changeInfoByUid() {
    User user = new User();
    user.setPhone("123123");
    user.setUid(2);
    user.setEmail("1321@qq.com");
    user.setGender(0);
    user.setModifiedUser("王五");
    user.setModifiedTime(new Date());


}
```

#### 业务层

**1.异常规划**

1、打开个人资料页面时，可能会因找不到用户数据而无法正确显示个人资料，抛出UserNotFoundException异常

2、当点击修改按钮时，可能会因为找不到用户数据而找不到要修改的用户是哪个，抛出UserNotFoundException异常，或在执行修改时系统出现问题，抛出UpdateException异常。

**2、添加抽象方法**

```java
/**
 * 修改用户资料
 * @param uid
 * @param username
 * @param user
 */
void changeInfoByUid(Integer uid, String username, User user);

/**
 * 查询用户数据，用来回显给用户资料页面
 * @param uid
 * @return 
 */
User findUserByUid(Integer uid);
```

**3、实现抽象方法**

```java
@Override
public void changeInfoByUid(Integer uid, String username, User user) {
    User res = userMapper.findByUid(uid);
    if(res == null || res.getIsDelete() == 1){
        throw new UserNotFoundException("用户没找到");
    }
    user.setUid(uid);
    user.setModifiedUser(username);
    user.setModifiedTime(new Date());
    Integer integer = userMapper.changeInfoByUid(user);
    if(integer != 1){
        throw new UpdateException("资料修改时出现未知错误");
    }
}

@Override
public User findUserByUid(Integer uid) {
    User res = userMapper.findByUid(uid);
    if(res == null || res.getIsDelete() == 1){
        throw new UserNotFoundException("用户不存在");
    }
    //查询用户资料，将结果中的个人资料信息保存到user对象中，最终返回给前端获取。
    User user = new User();
    user.setUsername(res.getUsername());
    user.setPhone(res.getPhone());
    user.setEmail(res.getEmail());
    user.setGender(res.getGender());
    return user;
}
```

4**、测试：**

```java
@Test
public void changeInfoByUid() {
    User user = new User();
    user.setPhone("123123");
    user.setUid(2);
    user.setEmail("1321@qq.com");
    user.setGender(0);
    user.setModifiedUser("王五");
    user.setModifiedTime(new Date());


}

@Test
public void findUserByUid() {
    User user = new User();
    user.setUid(2);
    System.out.println(service.findUserByUid(user.getUid()));
}
```

#### 控制层

**1、处理异常**

使用之前处理异常分支即可。

**2、设计请求**

1、设计用户点击个人资料页面时发送的请求以及请求的处理

```
请求路径：/users/get_by_id 
请求参数：HttpSession session 
请求类型：GET 
响应结果：JsonResult<User>
```

2、设计用户点击修改资料按钮的发送的请求以及请求的处理

```sql
请求路径：/users/change_info 
请求参数：User user, HttpSession session 
请求类型：POST 
响应结果：JsonResult<Void>
```

```java
/**
 * 处理访问用户资料页面的请求
 * @param session
 * @return
 */
@RequestMapping("get_by_id")
public JsonResult<User> getInfoByUid(HttpSession session){
    Integer uid = getUidFromSession(session);
    User res = service.findUserByUid(uid);
    return new JsonResult<User>(OK,res);
}

/**
 * 处理修改用户资料的请求
 * @param user
 * @param session
 * @return
 */
@RequestMapping("change_info")
public JsonResult<Void> changeInfo(User user, HttpSession session){
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    service.changeInfoByUid(uid, username, user);
    return new JsonResult<>(OK);
}
```

**3、测试**

3.完成后启动项目，打开浏览器先登录，再访问http://localhost:8080/users/change_info?phone=17858800000&email=admin07@cy.com&gender=1进行测试。

#### **前端**

设计两个ajax请求

$(document).ready方法在加载当前页面时会触发响应事件，发送ajax请求。

```html
<script type="text/javascript">
   $(document).ready(function() {
      $.ajax({
         url: "/users/get_by_id",
         type: "GET",
         dataType: "JSON",
         success: function(json) {
            if (json.state == 200) {
                <!--从控制层发送的user对象变为json类型，并获取相关的资料填充个人资料-->
               $("#username").val(json.data.username);
               $("#phone").val(json.data.phone);
               $("#email").val(json.data.email);
               let radio = json.data.gender == 0 ? $("#gender-female") : $("#gender-male");
               radio.prop("checked", "checked");
            } else {
               alert("获取用户信息失败！" + json.message);
            }
         }
      });
   });
   $("#btn-change-info").click(function () {
      $.ajax({
         url: "/users/change_info",
         type: "POST",
         data: $("#form-change-info").serialize(),
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
               alert("修改成功")
               //刷新修改页面
               location.href = "userdata.html"
            }else {
               alert("修改失败: "+json.message)
            }
         },
         error: function (xhr) {
            alert("登录时遇到意外的错误" + xhr.message)
         }
      })
   });
</script>
```

### 5、上传用户头像

用户信息的用户头像保存用户头像的资源路径，前端图片区域访问服务器的路径，即可获得图片。

#### 持久层

**1、规划sql语句**

通过用户id修改用户的头像，并更新修改人，修改时间。

```sql
update t_user set avatar=?, modified_user=?, modified_time=? where uid=?
```

**2、添加抽象方法**

```java
 /**
     * 修改用户头像
     * @param uid 用户id，通过session获取
     * @param avatar 用户头像地址，通过上传的文件获取
     * @param modifiedUser 通过session获取
     * @param modifiedTime 直接new获取
     * @return 影响数据库行数
     */
	//当sql中的占位符名字和参数不同，可以使用@Param来建立联系
    Integer updateAvatarByUid(@Param("uid") Integer uid,
                              @Param("avatar") String avatar,
                              @Param("modifiedUser") String modifiedUser,
                              @Param("modifiedTime")Date  modifiedTime);
}
```

**3、Mapper.xmlSQL映射**

```xml
<update id="updateAvatarByUid">
    UPDATE store.t_user
    SET avatar=#{avatar}, modified_user=#{modifiedUser}, modified_time=#{modifiedTime}
    WHERE uid=#{uid}
</update>
```

**4、测试控制层**

```java
@Test
void updateAvatar(){
    System.out.println(userMapper.updateAvatarByUid(3, "/img/header", "小米", new Date()));
}
```

#### 业务层

**1.规划异常**

在更新头像前可能会遇到用户信息不存在问题，UserNotFoundException异常，或在更新头像时，更新到数据库失败，UpdateException异常。

**2、添加抽象方法**

```java
/**
 * 更新头像业务方法
 * @param uid 通过会话获得
 * @param avatar 通过上传的文件信息获得
 * @param username 通过session获得
 */
void updateAvatar(Integer uid, String avatar, String username);
```

**3、实现抽象方法**

```java
@Override
public void updateAvatar(Integer uid, String avatar, String username) {
    User res = userMapper.findByUid(uid);
    if(res == null || res.getIsDelete() == 1){
        throw new UserNotFoundException("用户不存在");
    }
    Integer integer = userMapper.updateAvatarByUid(uid, avatar, username, new Date());
    if(integer != 1){
        throw new UpdateException("头像修改时出现未知问题");
    }
}
```

**5、测试方法**

```java
@Test
public void updateAvatar() {
    service.updateAvatar(3,"/img/header002","小明");
}
```

#### 控制层

**1、处理异常**

当上传头像时，可能会遇到上传等异常，创建文件上传异常基类。

```java
/** 文件上传相关异常的基类 */
public class FileUploadException extends RuntimeException {
    public FileUploadException() {
        super();
    }

    public FileUploadException(String message) {
        super(message);
    }

    public FileUploadException(String message, Throwable cause) {
        super(message, cause);
    }

    public FileUploadException(Throwable cause) {
        super(cause);
    }

    protected FileUploadException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

**创建文件上传子类继承基类**

分别表示：

1、 上传的文件为空

2、上传的文件大小超出了限制值

3、上传的文件类型超出了限制

4、上传的文件状态异常

5、上传文件时读写异常

![image-20220525000041577](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220525000041577.png)

**在异常处理基类添加异常分支**

```java
@ExceptionHandler({ServiceException.class,FileUploadException.class})
public JsonResult<Void> handleException(Throwable e){
    JsonResult<Void> result = new JsonResult<>(e);
    if(e instanceof UsernameDuplicateException){
        result.setState(4000);
    }else if(e instanceof UserNotFoundException){
        result.setState(4001);
    }else if(e instanceof PasswordNotMatchException){
        result.setState(4002);
    }else if(e instanceof UpdateException){
        result.setState(4003);
    }else if(e instanceof InsertException){
        result.setState(5000);
    }else if (e instanceof FileEmptyException) {
        result.setState(6000);
    }else if (e instanceof FileSizeException) {
        result.setState(6001);
    }else if (e instanceof FileTypeException) {
        result.setState(6002);
    }else if (e instanceof FileStateException) {
        result.setState(6003);
    }else if (e instanceof FileUploadIOException) {
        result.setState(6004);
    }
    return result;
}
```

**2、设计请求**

当用户点击头像修改按钮，发送请求时。控制层方法会将头像的文件路径（JsonResult<String>）发送到前端，传递给ajax请求的json对象，通过json对象的avatar属性将前端的头像路径替换即可。

```java
请求路径：/users/change_avatar
请求参数：MultipartFile file, HttpSession session
请求类型：POST
响应结果：JsonResult<String>
```

**3、处理请求**

```java
public static final int MAX_SIZE = 10*1024*1024;
public static final List<String> AVATAR_TYPE = new ArrayList<>();
@RequestMapping("update_avatar")
public JsonResult<String> updateAvatar(HttpSession session, MultipartFile file){
    AVATAR_TYPE.add("image/jpeg");
    AVATAR_TYPE.add("image/png");
    AVATAR_TYPE.add("image/bmp");
    AVATAR_TYPE.add("image/gif");
    if (file.isEmpty()){
        throw new FileEmptyException("文件为空");
    }
    if(file.getSize() > MAX_SIZE){
        throw new FileSizeException("文件尺寸不能大于10M");
    }
    if(!AVATAR_TYPE.contains(file.getContentType())){
        throw new FileTypeException("文件类型不匹配");
    }
    //在工程项目下创建upload目录，保存上传头像文件
    String parent = session.getServletContext().getRealPath("upload");
    File dir = new File(parent);
    if(!dir.exists()){
        dir.mkdir();
    }
    System.out.println(parent);
    //在parent目录下创建空文件，文件名为uuid加上传文件后缀名
    int index = file.getOriginalFilename().indexOf(".");
    String suffix = file.getOriginalFilename().substring(index);
    String filename = UUID.randomUUID().toString().toUpperCase() + suffix;
    File path = new File(dir, filename);
    //将文件数据传输给文件
    try {
        file.transferTo(path);
    } catch (IllegalStateException e) {
        throw new FileUploadIOException("文件状态异常，或已被删除");
    } catch (IOException e) {
        throw new FileUploadIOException("上传文件时读写异常");
    }
    //保存服务器头像文件的路径
    String avatar = "/upload/" + filename;
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    service.updateAvatar(uid, avatar, username);
    return new JsonResult<String>(OK,avatar);
}
```

#### 前端

**1、设置上传文件的大小**

方式1：

在properties文件配置上传文件的大小限制

```properties
spring.servlet.multipart.max-file-size=10MB//一个文件的最大尺寸
spring.servlet.multipart.max-request-size=15MB//一个文件加请求的最大尺寸
```

方式2：

使用getMultipartConfigElement方法返回工厂对象实现。

```java
@SpringBootApplication
@MapperScan("com.hyh.cstore.mapper")
public class cStoreApplication {

    public static void main(String[] args) {
        SpringApplication.run(StoreApplication.class, args);
    }

    @Bean
    public MultipartConfigElement getMultipartConfigElement() {
        MultipartConfigFactory factory = new MultipartConfigFactory();
        // DataSize dataSize = DataSize.ofMegabytes(10);
        // 设置文件最大10M，DataUnit提供5中类型B,KB,MB,GB,TB
        factory.setMaxFileSize(DataSize.of(10, DataUnit.MEGABYTES));
        factory.setMaxRequestSize(DataSize.of(10, DataUnit.MEGABYTES));
        // 设置总上传数据总大小10M
        return factory.createMultipartConfig();
    }
}
```

**2.修改前端页面，设计ajax请求**

给表单添加id。为了可以设计点击事件，发送ajax请求，将提交按钮改为普通按钮，并添加id。

```html
<form id="update-avatar-form" enctype="multipart/form-data" class="form-horizontal" role="form" >
   <div class="form-group">
      <label class="col-md-2 control-label">选择头像:</label>
      <div class="col-md-5">
         <img id="img-avatar" src="../images/index/user.jpg" class="img-responsive" />
      </div>
      <div class="clearfix"></div>
      <div class="col-md-offset-2 col-md-4">
         <input type="file" name="file">
      </div>
   </div>
   <div class="form-group">
      <div class="col-sm-offset-2 col-sm-10">
         <input type="button"  id="update-avatar-button" class="btn btn-primary" value="上传" />
      </div>
   </div>
</form>
```

在登录成功后将该用户的头像地址保存到cookie中。

```html
<script>
   $("#btn-login").click(function () {
      $.ajax({
         url: "/users/login",
         type: "POST",
         data: $("#form-login").serialize(),
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
                //一旦登录成功将头像地址保存到cookie中
               $.cookie("avatar", json.data,{expires: 7})
               alert("登录成功")
               //跳转到首页
               location.href = "index.html"
            }else if(json.state == 4001) {
               alert(json.message)
            }
            else if(json.state == 4002) {
               alert(json.message)
            }
         },
         error: function (xhr) {
            alert("登录时遇到意外的错误" + xhr.message)
         }
      });
   });
</script>
```

在头像页面加上cookie的js标签，以获取cookie中的头像地址

```js
<script src="../bootstrap3/js/jquery.cookie.js" type="text/javascript" charset="utf-8">
```

设计头像页面的js事件以及ajax请求

```html
<script type="text/javascript">
    <!-- 点击头像页面，加载头像页面时，将cookie里的头像地址值赋予头像标签，即可自动显示用户标签-->
   $(document).ready(function (){
      console.log($.cookie("avatar"))
      $("#img-avatar").attr("src", $.cookie("avatar"))
   });
    <!--修改用户头像-->
   $("#update-avatar-button").click(function () {
      $.ajax({
         url: "/users/update_avatar",
         type: "POST",
         data: new FormData($("#update-avatar-form")[0]),//将表单数据以文件等复杂形式保存到data
         dataType: "JSON",
         processData: false,//取消ajax默认处理String类型
         contentType: false,//取消ajax默认发送String类型
         success: function (json) {
            if(json.state == 200){
               $("#img-avatar").attr("src", json.data)//将头像地址更改为新的，刚发送到前端的头像地址
               $.cookie("avatar", json.data, {expires: 7})//将新的头像地址重新封装到cookie中，下次再加载头像页面时，自动加载新的头像
               alert("修改成功")
            }else {
               alert("修改失败: "+json.message)
            }
         },
         error: function (xhr) {
            alert("修改头像时遇到意外的错误" + xhr.message)
         }
      });
   });
</script>
```

**测试：**

![image-20220525105256344](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220525105256344.png)

### 6、新增收货地址

​		**关于收货地址数据的管理，涉及的功能有：增加，删除，修改，设为默认，显示列表。这些功能的开发顺序为：增加-显示列表-设为默认-删除-修改。**

#### 创建地址数据库表

```sql
CREATE TABLE t_address (
	aid INT AUTO_INCREMENT COMMENT '收货地址id',
	uid INT COMMENT '归属的用户id',
	name VARCHAR(20) COMMENT '收货人姓名',
	province_name VARCHAR(15) COMMENT '省-名称',
	province_code CHAR(6) COMMENT '省-行政代号',
	city_name VARCHAR(15) COMMENT '市-名称',
	city_code CHAR(6) COMMENT '市-行政代号',
	area_name VARCHAR(15) COMMENT '区-名称',
	area_code CHAR(6) COMMENT '区-行政代号',
	zip CHAR(6) COMMENT '邮政编码',
	address VARCHAR(50) COMMENT '详细地址',
	phone VARCHAR(20) COMMENT '手机',
	tel VARCHAR(20) COMMENT '固话',
	tag VARCHAR(6) COMMENT '标签',
	is_default INT COMMENT '是否默认：0-不默认，1-默认',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (aid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### 创建相应实体类

```java
/** 收货地址数据的实体类 */
public class Address extends BaseEntity implements Serializable {
    private Integer aid;
    private Integer uid;
    private String name;
    private String provinceName;
    private String provinceCode;
    private String cityName;
    private String cityCode;
    private String areaName;
    private String areaCode;
    private String zip;
    private String address;
    private String phone;
    private String tel;
    private String tag;
    private Integer isDefault;tter、Generate hashCode() and equals()、toString()
}
```

#### 持久层

**1、规划sql语句**

1、添加收获地址信息的sql语句

```sql
INSERT INTO t_address (除了aid以外的字段列表) VALUES (匹配的值列表)
```

2、因为前端表单传过来的地址数据不包含地区的名字，所以还得根据传过来的地区代码来查询地区名字并保存。

```sql
SELECT name FROM store.t_dict_district WHERE code=#{code}
```

**2、新建接口以及抽象方法**

```java
import com.hyh.cstore.entity.Address;
/**收获地址接口*/
public interface AddressMapper {
    /**
     * 添加新收获地址
     * @param address 业务层将完整的地址信息传入
     * @return 影响的行数
     */
    Integer insert(Address address);

    /**
     * 统计一个用户的收获地址数量，不能大于20个
     * @param uid 从session中获取
     * @return 影响的行数
     */
    Integer countByUid(Integer uid);
    /**
     * 根据地区号码得到地区名
     * @param code  从前端表单传过来的地址号码
     * @return 地区名
     */
    String findNameByCode(String code);
}
```

**3、新建AddressMapper.xml，建立sql映射**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.cstore.mapper.AddressMapper">
    <insert id="insert" useGeneratedKeys="true" keyProperty="aid">
        INSERT INTO store.t_address (
            uid, name, province_name, province_code, city_name, city_code, area_name, area_code, zip,
            address, phone, tel,tag, is_default, created_user, created_time, modified_user, modified_time
        ) VALUES (
                     #{uid}, #{name}, #{provinceName}, #{provinceCode}, #{cityName}, #{cityCode}, #{areaName},
                     #{areaCode}, #{zip}, #{address}, #{phone}, #{tel}, #{tag}, #{isDefault}, #{createdUser},
                     #{createdTime}, #{modifiedUser}, #{modifiedTime}
                 )
    </insert>
    <select id="countByUid" resultType="java.lang.Integer">
        SELECT count(*) from store.t_address WHERE uid=#{uid}
    </select>
    
    <select id="findNameByCode" resultType="java.lang.String">
        SELECT name FROM store.t_dict_district WHERE code=#{code}
    </select>
</mapper>
```

**4、测试：**

```java
@Test
public void insertAddress() {
    Address address = new Address();
    address.setUid(4);
    address.setName("admin");
    address.setPhone("17858802974");
    address.setAddress("雁塔区小寨赛格");
    Integer rows = addressMapper.insert(address);
    System.out.println("rows=" + rows);
}

@Test
public void countByUid() {
    Integer uid = 4;
    Integer count = addressMapper.countByUid(uid);
    System.out.println("count=" + count);
}
```

#### 业务层

**1、异常规划**

当一个用户的收货地址个数超过20个，抛出AddressCountLimitException异常。

当数据库用户不存在，抛出UserNotFoundException异常

当保存新增地址出现异常，抛出UpdateException异常

**创建UpdateException异常类**

```java
public class AddressCountLimitException extends ServiceException{
    public AddressCountLimitException() {
    }
    ......
```

**2、创建接口和抽象方法**

创建IAddressService接口以及添加addNewAddress方法

```java
import com.hyh.cstore.entity.Address;
/**地址业务层接口*/
public interface IAddressService {
    /**
     * 添加新的收货地址
     * @param uid 从session中传递过来
     * @param username 从session中传递过来
     * @param address 从表单数据获取注入address对象
     */
    void addNewAddress(Integer uid, String username, Address address);
}
```

**3、创建实现类实现抽象方法**

创建IAddressService接口的实现类，以及实现addNewAddress方法

```java
@Service
public class AddressServiceImpl implements IAddressService {
    @Autowired
    AddressMapper addressMapper;
    @Autowired
    UserMapper userMapper;
    @Value("${address.count-max}")
    private Integer maxCount;
    @Override
    public void addNewAddress(Integer uid, String username, Address address) {
        User user = userMapper.findByUid(uid);
        if(user == null){
            throw new UserNotFoundException("当前用户不存在");
        }
        Integer count = addressMapper.countByUid(uid);
        if(count >= maxCount){
            throw new AddressCountLimitException("收货地址数超过最大上限");
        }
        //如果是第一条新添地址，则设置为默认地址
        address.setIsDefault(count == 0 ? 1 : 0);
        address.setCreatedUser(username);
        address.setCreatedTime(new Date());
        address.setModifiedUser(username);
        address.setModifiedTime(new Date());
        //根据地区码获得地区名，并保存到地址对象中
        String provinceName = addressMapper.findNameByCode(address.getProvinceCode());
        String cityName = addressMapper.findNameByCode(address.getCityCode());
        String areaName = addressMapper.findNameByCode(address.getAreaCode());
        address.setProvinceName(provinceName);
        address.setCityName(cityName);
        address.setAreaName(areaName);
        //将地址添加到数据库
        Integer insert = addressMapper.insert(address);
        if(insert != 1){
            throw new UpdateException("添加新地址出现了未知的异常");
        }
    }
}

```

在properties配置文件添加自定义配置：收货地址最大数

```properties
address.count-max=20
```

**4、测试**

```java
public class AddressServiceTest {
    @Autowired
    IAddressService service;
    @Test
    void addNewAddress(){
        Address address = new Address();
        address.setName("小明");
        address.setAddress("北京");
        address.setPhone("13923412312");
        service.addNewAddress(1,"张三",address);

    }
}
```

#### 控制层

**1、处理异常**

在BaseController添加异常分支

```java
else if(e instanceof AddressCountLimitException){
    result.setState(4004);
}
```

**2、请求设计**

```
请求路径：/addresses/add_new_address
请求参数：Address address, HttpSession session
请求类型：POST
响应结果：JsonResult<Void>
```

**3、添加控制器方法处理请求**

```java
/**添加新收获地址的控制层*/
@RestController
@RequestMapping("addresses")
public class AddressController extends BaseController{
    @Autowired
    IAddressService service;
    @RequestMapping("add_new_address")
    public JsonResult<Void> addNewAddress(HttpSession session, Address address){
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        service.addNewAddress(uid, username, address);
        return new JsonResult<>(OK);
    }
}
```

**4、测试**

完成后启动项目，打开浏览器先登录，再访问http://localhost:8080/web/addAddress.html页面

#### 前端页面

**设计点击相应事件和ajax请求**

点击保存新增地址按钮后发送ajax请求将新增收货地址保存到数据库表中

```java
<script type="text/javascript">
   $("#btn-add-new-address").click(function () {
      $.ajax({
         url: "/addresses/add_new_address",
         type: "POST",
         data: $("#form-add-new-address").serialize(),
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
               alert("添加新地址成功")
            }else{
               alert("添加失败")
            }
         },
         error: function (xhr) {
            alert("添加地址时遇到意外的错误" + xhr.message)
         }
      });
   });
</script>
```

### 获取省市区列表

其实前端已经给我们提供了显示下拉列表的js文件，但是为了节省前端资源，我们设计一个前后端的获取省市区列表。

#### 持久层

**1、规划sql语句**

```sql
select * from t_dict_district where parent=?
```

**2、创建接口和抽象方法**

```java
/**
 * 省市区列表接口
 */
public interface IDistrictService {
    /**
     * 返回根据父区域查询到的区域列表
     */
    List<District> getByParent(String parent);
}
```

**3、创建DistrictMapper.xml映射**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.cstore.mapper.DistrictMapper">
    <select id="findByParent" resultType="com.hyh.cstore.entity.District">
        SELECT id,parent,code,name FROM store.t_dict_district WHERE parent=#{parent}
    </select>
</mapper>
```

**4、测试**

#### 业务层

**1、异常规划**

无异常规划

**2、创建接口和抽象方法**

```java
/**
 * 省市区列表业务接口
 */
public interface IDistrictService {
    /**
     * 返回根据父区域查询到的区域列表
     */
    List<District> getByParent(String parent);
}
```

**3、创建接口实现类实现抽象方法**

```java
@Service
public class DistrictServiceImpl implements IDistrictService {
    @Autowired
    DistrictMapper districtMapper;
    @Override
    public List<District> getByParent(String parent) {
        List<District> districtList = districtMapper.findByParent(parent);
        for(District l : districtList){
            l.setId(null);
            l.setParent(null);
        }
        return districtList;
    }
}
```

**4、测试**

#### 控制层

**1、异常处理**

无异常处理

**2、设计请求**

```
请求路径：/districts/
请求参数：String parent
请求类型：GET
响应结果：JsonResult<List<District>>
是否拦截：否，需要在拦截器的配置中添加白名单
```

**3、创建控制器方法处理请求**

```java
@RestController
@RequestMapping("districts")
public class DistrictController extends BaseController{
    @Autowired
    IDistrictService service;
    @RequestMapping({"", "/"})
    JsonResult<List<District>> getByParent(String parent){
        List<District> list = service.getByParent(parent);
        return new JsonResult<>(OK,list);
    }
}
```

**4、测试**

4.完成后启动项目，打开浏览器（不需要登录），直接访问http://localhost:8080/districts?parent=86进行测试。

![](C:\Users\鹤\Desktop\项目\电脑商城\SpringBoot电脑商城项目-V1.0\unit05-用户收货管理\img\3.png)

#### 前端

**1、在新增地址页面设计列表响应以及ajax请求**

```html
<script type="text/javascript">
   let defaultOption = '<option value="0">-------请选择-------</option>';
   $(document).ready(function (){
      showProvinceList();
      $("#city-list").append(defaultOption);
      $("#area-list").append(defaultOption);
   });
   //change方法在该标签的状态发生改变时调用，即下拉列表的选择发生改变等。
   $("#province-list").change(function (){
      showCityList();
   });
   $("#city-list").change(function (){
      showAreaList();
   });
   function showProvinceList() {
      $("#province-list").append(defaultOption);
      $.ajax({
         url: "/districts",
         type: "POST",
         data: "parent=86",
         dataType: "JSON",
         success: function (json) {
            if (json.state == 200) {
               let list = json.data;
               //将返回给前端的list集合遍历，添加到下拉列表中
               for (let i = 0; i < list.length; i++) {
                  let option = '<option value="' + list[i].code + '">' + list[i].name + '</option>';
                  $("#province-list").append(option);
               }
            } else {
               alert("省选择失败");
            }
         },
         error: function (xhr) {
            alert("选择时遇到意外的错误" + xhr.message)
         }
      });
   }
   function showCityList(){
      let parent = $("#province-list").val();
      //当父区域选择发生改变，则将子区域的下拉列表清空，然后都变为请选择选项。
      $("#city-list").empty();
      $("#area-list").empty();

      $("#city-list").append(defaultOption);
      $("#area-list").append(defaultOption);
      //当下拉列表的值为0，即请选择的下拉项，就不用发ajax请求搜索了
      if(parent == 0){
         return;
      }
      $.ajax({
         url: "/districts",
         type: "POST",
         data: "parent=" + parent,
         dataType: "JSON",
         success: function (json) {
            if(json.state == 200){
               let list = json.data;
               for (let i = 0; i < list.length; i++) {
                  let option = '<option value="'+list[i].code+'">'+list[i].name+'</option>';
                  $("#city-list").append(option);
               }
            }else {
               alert("市选择失败");
            }
         },
         error: function (xhr) {
            alert("选择时遇到意外的错误" + xhr.message)
         }
      });
   }
   function showAreaList() {
      $("#area-list").empty();
      $("#area-list").append(defaultOption);
      $.ajax({
         url: "/districts",
         type: "POST",
         data: "parent=" + $("#city-list").val(),
         dataType: "JSON",
         success: function (json) {
            if (json.state == 200) {
               let list = json.data;
               for (let i = 0; i < list.length; i++) {
                  let option = '<option value="' + list[i].code + '">' + list[i].name + '</option>';
                  $("#area-list").append(option);
               }
            } else {
               alert("地区选择失败");
            }
         },
         error: function (xhr) {
            alert("选择时遇到意外的错误" + xhr.message)
         }
      });
   }
</script>
```

**2、测试**

自定义的下拉列表

![image-20220526141519208](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220526141519208.png)

### 7、收货地址列表展示

### 8、设置默认收获地址

### 9、删除收货地址

#### 持久层

**1、规划sql语句**

1、删除时判断地址存不存在

不用规划

2、根据aid删除收货地址

```sql
delete from t_address where aid=?
```

3、删除默认地址后，将设置日期最大的收货地址设为默认地址

```sql
select * from t_address where uid=? order by modified_time desc limit 0,1
```

**2、创建对应的Mapper映射sql语句**

```xml
<delete id="deleteByAid">
    DELETE FROM store.t_address WHERE aid=#{aid}
</delete>

<select id="findLastModified" resultMap="addressMap">
    SELECT * FROM store.t_address WHERE uid=#{uid} ORDER BY modified_time DESC LIMIT 0, 1
</select>
```

**3、测试：**

```JAVA
@Test
public void deleteByAid() {
    Integer aid = 12;
    Integer rows = mapper.deleteByAid(aid);
    System.out.println("rows=" + rows);
}

@Test
public void findLastModified() {
    Integer uid = 4;
    Address result = mapper.findLastModified(uid);
    System.out.println(result);
}
```

#### 业务层

**1、规划异常**

在执行删除操作时，可能会删除数据失败，此时抛出DeleteException异常

创建DeleteException异常类

**2、创建抽象方法**

```java
/**
 * 删除收货地址
 * @param uid 用户id
 * @param aid 地址id
 * @param username 删除默认地址后，重新设置默认地址需要用到
 */
void deleteAddress(Integer uid, Integer aid, String username);
```

**3、实现抽象方法**

```java
@Override
public void deleteAddress(Integer uid, Integer aid, String username) {
    Address res = addressMapper.findByAid(aid);
    if(res == null){
        throw new AddressNotFoundException("该地址不存在");
    }
    if(!res.getUid().equals(uid)){
        throw new AccessDeniedException("非法访问");
    }
    Integer delete = addressMapper.deleteByAid(aid);
    if (delete != 1){
        throw new DeleteException("删除时发生异常");
    }
    //删除的是非默认地址
    if(res.getIsDefault() == 0){
        return;
    }
    //删除唯一一条地址(默认地址)
    if(addressMapper.countByUid(uid) == 0){
        return;
    }
    //删除默认地址，且还有非默认地址
    Address lastModified = addressMapper.findLastModified(uid);
    Integer update = addressMapper.updateDefaultByAid(lastModified.getAid(), username, new Date());
    if(update != 1){
        throw new UpdateException("更新默认地址时发生错误");
    }

}
```

**4、测试**

```java
@Test
public void delete() {
    try {
        Integer aid = 10;
        Integer uid = 4;
        String username = "明明";
        service.deleteAddress(uid, aid, username);
        System.out.println("OK.");
    } catch (ServiceException e) {
        System.out.println(e.getClass().getSimpleName());
        System.out.println(e.getMessage());
    }
}
```

#### 控制层

**1、处理异常**

添加异常处理分支

```java
else if(e instanceof DeleteException){
    result.setState(5001);
}
```

**2 设计请求**

设计用户提交的请求，并设计响应的方式。

	请求路径：/addresses/{aid}/delete
	请求参数：@PathVariable("aid") Integer aid, HttpSession session
	请求类型：POST
	响应结果：JsonResult<Void>

**3、创建删除操作的控制器方法**

```java
@RequestMapping("{aid}/deleteAddress")
public JsonResult<Void> deleteAddress(HttpSession session,
                                   @PathVariable("aid") Integer aid){
    service.deleteAddress(getUidFromSession(session), aid, getUsernameFromSession(session));
    return new JsonResult<>(OK);
}
```

#### 前端

**1、设计Ajax请求**

1、设计删除的函数

```js
function deleteByAid(aid) {
   $.ajax({
      url: "/addresses/" + aid + "/deleteAddress",
      type: "POST",
      dataType: "JSON",
      success: function (json) {
         if (json.state == 200) {
            alert("删除成功")
            showAddressList();
         } else {
            alert("删除地址发生未知错误");
         }
      },
      error: function (xhr) {
         alert("删除时遇到意外的错误" + xhr.message)
      }
   });
}
```

2、在删除的标签加上onclick属性，调用删除方法

```js
<td><a onclick="setDefault(#{aid})" class="btn btn-xs add-def btn-default">设为默认</a></td>
```

**2、测试**

![image-20220527144200863](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220527144200863.png)

### 10、热销商品

#### 创建数据库表

```sql
CREATE TABLE t_product (
  id int(20) NOT NULL COMMENT '商品id',
  category_id int(20) DEFAULT NULL COMMENT '分类id',
  item_type varchar(100) DEFAULT NULL COMMENT '商品系列',
  title varchar(100) DEFAULT NULL COMMENT '商品标题',
  sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点',
  price bigint(20) DEFAULT NULL COMMENT '商品单价',
  num int(10) DEFAULT NULL COMMENT '库存数量',
  image varchar(500) DEFAULT NULL COMMENT '图片路径',
  status int(1) DEFAULT '1' COMMENT '商品状态  1：上架   2：下架   3：删除',
  priority int(10) DEFAULT NULL COMMENT '显示优先级',
  created_time datetime DEFAULT NULL COMMENT '创建时间',
  modified_time datetime DEFAULT NULL COMMENT '最后修改时间',
  created_user varchar(50) DEFAULT NULL COMMENT '创建人',
  modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### 创建实体类

```java
/** 商品数据的实体类 */
public class Product extends BaseEntity implements Serializable {
    private Integer id;
    private Integer categoryId;
    private String itemType;
    private String title;
    private String sellPoint;
    private Long price;
    private Integer num;
    private String image;
    private Integer status;
    private Integer priority;

    // Generate: Getter and Setter、Generate hashCode() and equals()、toString()
}
```

#### 持久层

**1 规划需要执行的SQL语句**

查询排名前四的热销商品列表的SQL语句大致是。

```mysql
SELECT * FROM t_product WHERE status=1 ORDER BY priority DESC LIMIT 0,4
```

**2 接口与抽象方法**

```java
/**商品mapper接口*/
public interface ProductMapper {
    /**查询热销商品
     * @return
     */
    List<Product> findHotList();
}
```

**3 配置SQL映射**

```xlm
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.cstore.mapper.ProductMapper">
    <resultMap id="ProductMap" type="com.hyh.cstore.entity.Product">
        <id column="id" property="id"/>
        <result column="category_id" property="categoryId"/>
        <result column="item_type" property="itemType"/>
        <result column="sell_point" property="sellPoint"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <!-- 查询热销商品的前四名：List<Product> findHostList() -->
    <select id="findHotList" resultMap="ProductMap">
        SELECT
            *
        FROM
            store.t_product
        WHERE
            status=1
        ORDER BY
            priority DESC
        LIMIT 0,4
    </select>
</mapper>
```

**4、测试**

#### 业务层

**1、异常规划**

无

**2、创建接口和抽象方法**

```java
/**
 * 省市区列表业务接口
 */
public interface IDistrictService {
    /**
     * 返回根据父区域查询到的区域列表
     */
    List<District> getByParent(String parent);
}
```

**3、实现类**

```java
public class ProductServiceImpl implements IProductService {
    @Autowired
    private ProductMapper productMapper;

    @Override
    public List<Product> showHotList() {
        List<Product> list = productMapper.findHotList();
        for (Product product : list) {
            product.setPriority(null);
            product.setCreatedUser(null);
            product.setCreatedTime(null);
            product.setModifiedUser(null);
            product.setModifiedTime(null);
        }
        return list;
    }
}
```

**4、测试**

#### 控制层

**1 、处理异常**

> **说明**：无异常。

**2 、设计请求**

1.设计用户提交的请求，并设计响应的方式。

	请求路径：/products/hot_list
	请求参数：无
	请求类型：GET
	响应结果：JsonResult<List<Product>>
	是否拦截：否，需要将index.html和products/**添加到白名单

2.在LoginInterceptorConfigurer类中将products/**请求添加到白名单。

```java
patterns.add("/products/**");
```

```java
@RestController
@RequestMapping("product")
public class ProductController extends BaseController{
    @Autowired
    private IProductService productService;

    @RequestMapping("hot_list")
    public JsonResult<List<Product>> getHotList() {
        List<Product> data = productService.showHotList();
        return new JsonResult<>(OK, data);
    }
}
```

**3、测试**

#### 前端

**1、设置js函数即ajax请求**

```js
		<script type="text/javascript">
			$(document).ready(function() {
				showHotList();
			});

			function showHotList() {
				$("#hot-list").empty();
				$.ajax({
					url: "/products/hot_list",
					type: "GET",
					dataType: "JSON",
					success: function(json) {
						let list = json.data;
						console.log("count=" + list.length);
						for (let i = 0; i < list.length; i++) {
							console.log(list[i].title);
							let html = '<div class="col-md-12">'
									+ '<div class="col-md-7 text-row-2"><a href="product.html?id=#{id}">#{title}</a></div>'
									+ '<div class="col-md-2">¥#{price}</div>'
									+ '<div class="col-md-3"><img src="..#{image}collect.png" class="img-responsive" /></div>'
									+ '</div>';

							html = html.replace("#{id}", list[i].id);
							html = html.replace("#{title}", list[i].title);
							html = html.replace("#{price}", list[i].price);
							html = html.replace("#{image}", list[i].image);

							$("#hot-list").append(html);
						}
					}
				});
			}
		</script>
```

**2、测试**

### 11、商品详情

#### 持久层

**1、规划sql语句**

点击商品标签会进入商品的详情页，通过详情页的url地址id值查询该商品的详细信息

```sql
SELECT * FROM t_product WHERE id=?
```

**2、创建抽象方法**

```java
/**
 * 根据商品id查询商品详情
 * @param id 商品id
 * @return 匹配的商品详情，如果没有匹配的数据则返回null
 */
Product findById(Integer id);
```

**3、sql映射**

```xml
<select id="findById" resultMap="ProductMap">
    SELECT
        *
    FROM
        store.t_product
    WHERE
        id=#{id}
</select>
```

**4、测试**

#### 业务层

**1、规划异常**

如果商品数据不存在，应该抛出ProductNotFoundException异常

创建异常类：

```java
public class ProductNotFoundException extends ServiceException{
    public ProductNotFoundException() {
    }

    public ProductNotFoundException(String message) {
        super(message);
    }

    public ProductNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public ProductNotFoundException(Throwable cause) {
        super(cause);
    }

    public ProductNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

**2、添加抽象方法**

```java
/**
 * 根据商品id查询商品详情
 * @param id 商品id
 * @return 匹配的商品详情，如果没有匹配的数据则返回null
 */
Product findById(Integer id);
```

**3、实现抽象方法**

```java
@Override
public Product findById(Integer id) {
    // 根据参数id调用私有方法执行查询，获取商品数据
    Product product = productMapper.findById(id);
    // 判断查询结果是否为null
    if (product == null) {
        // 是：抛出ProductNotFoundException
        throw new ProductNotFoundException("尝试访问的商品数据不存在");
    }
    // 将查询结果中的部分属性设置为null
    product.setPriority(null);
    product.setCreatedUser(null);
    product.setCreatedTime(null);
    product.setModifiedUser(null);
    product.setModifiedTime(null);
    // 返回查询结果
    return product;
}
```

**4、测试**

#### 控制层

**1、处理异常**

添加异常分支

```java
else if (e instanceof ProductNotFoundException) {
	result.setState(4006);
}
```

**2、设计请求**

设计用户提交的请求，并设计响应的方式。

	请求路径：/products/{id}/details
	请求参数：@PathVariable("id") Integer id
	请求类型：GET
	响应结果：JsonResult<Product>

**3、 处理请求**

1.在ProductController类中添加处理请求的getById()方法。

```java
@GetMapping("{id}/details")
public JsonResult<Product> getById(@PathVariable("id") Integer id) {
    // 调用业务对象执行获取数据
    Product data = productService.findById(id);
    // 返回成功和数据
    return new JsonResult<Product>(OK, data);
}
```

#### 前端

1.检查在product.html页面body标签内部的最后是否引入jquery-getUrlParam.js文件，如果引入无需重复引入。

获取地址栏中的id值

```java
<script type="text/javascript" src="../js/jquery-getUrlParam.js"></script>
```

2.在product.html页面中body标签内部的最后添加获取当前商品详情的代码。

```javascript
<script type="text/javascript">
let id = $.getUrlParam("id");
console.log("id=" + id);
$(document).ready(function() {
    $.ajax({
        url: "/products/" + id + "/details",
        type: "GET",
        dataType: "JSON",
        success: function(json) {
            if (json.state == 200) {
                console.log("title=" + json.data.title);
                //给标签中添加内容
                $("#product-title").html(json.data.title);
                $("#product-sell-point").html(json.data.sellPoint);
                $("#product-price").html(json.data.price);
                //给1到5的大图片的标签设置图片地址，显示
                for (let i = 1; i <= 5; i++) {
                    $("#product-image-" + i + "-big").attr("src", ".." + json.data.image + i + "_big.png");
                    $("#product-image-" + i).attr("src", ".." + json.data.image + i + ".jpg");
                }
            } else if (json.state == 4007) { // 商品数据不存在的异常
                location.href = "index.html";
            } else {
                alert("获取商品信息失败！" + json.message);
            }
        }
    });
});
</script>
```

### 12、购物车

#### 创建数据库表即实体类

```sql
CREATE TABLE t_cart (
	cid INT AUTO_INCREMENT COMMENT '购物车数据id',
	uid INT NOT NULL COMMENT '用户id',
	pid INT NOT NULL COMMENT '商品id',
	price BIGINT COMMENT '加入时商品单价',
	num INT COMMENT '商品数量',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (cid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

```java
public class Cart extends EntityBase{
    private Integer cid;
    private Integer uid;
    private Integer pid;
    private Long price;
    private Integer num;
```

#### 持久层

**1、 规划SQL语句**

向购物车表中插入商品数据的SQL语句：

```mysql
insert into t_cart (除了cid以外的字段列表) values (匹配的值列表);
```

如果用户曾经将某个商品加入到购物车过，则点击“加入购物车”按钮只会对购物车中相同商品数量做递增操作。

```mysql
update t_cart set num=? where cid=?
```

关于判断“到底应该插入数据，还是修改数量”，可以通过“查询某用户是否已经添加某商品到购物车”来完成。如果查询到某结果，就表示该用户已经将该商品加入到购物车了，如果查询结果为null，则表示该用户没有添加过该商品。

```mysql
select * from t_cart where uid=? and pid=?
```

**2 、接口与抽象方法**

```java
public interface CartMapper {
    Integer insertCart(Cart cart);

    Integer updateNumByCid(Integer num, Integer cid, String modifiedUser, Date modifiedTime);

    Cart findByUidAndPid(Integer uid, Integer pid);

}
```

**3、mapper映射sql**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.cstore.mapper.CartMapper">
    <resultMap id="CartMap" type="com.hyh.cstore.entity.Cart">
        <id column="cid" property="cid"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>
    <insert id="insertCart" useGeneratedKeys="true" keyProperty="cid">
        INSERT INTO store.t_cart(uid, pid, price, num, created_user, created_time, modified_user, modified_time)
        VALUES (#{uid}, #{pid}, #{price}, #{num}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime})
    </insert>
    <update id="updateNumByCid">
        UPDATE store.t_cart SET num=#{num},modified_user=#{modifiedUser},modified_time=#{modifiedTime} WHERE cid=#{cid}
    </update>
    <select id="findByUidAndPid" resultMap="CartMap">
        SELECT * FROM store.t_cart WHERE uid=#{uid} AND pid=#{pid}
    </select>
</mapper>
```

**4、测试**

```java
@SpringBootTest
public class CartMapperTest {
    @Autowired
    private CartMapper cartMapper;

    @Test
    public void insert() {
        Cart cart = new Cart();
        cart.setUid(4);
        cart.setPid(2);
        cart.setNum(3);
        cart.setPrice(4L);
        Integer rows = cartMapper.insertCart(cart);
        System.out.println("rows=" + rows);
    }

    @Test
    public void updateNumByCid() {
        Integer cid = 1;
        Integer num = 10;
        String modifiedUser = "购物车管理员";
        Date modifiedTime = new Date();
        Integer rows = cartMapper.updateNumByCid(num, cid, modifiedUser, modifiedTime);
        System.out.println("rows=" + rows);
    }

    @Test
    public void findByUidAndPid() {
        Integer uid = 4;
        Integer pid = 2;
        Cart result = cartMapper.findByUidAndPid(uid, pid);
        System.out.println(result);
    }
}
```

#### 业务层

**1、规划异常**

向购物车表插入数据和更新数据库可能出现异常。InsertException异常、UpdateException异常

无需再定义

**2、创建接口和抽象方法**

```java
/**将添加商品数量的业务层接口*/
public interface ICartService {
    /**
     * 添加商品到购物车
     * @param uid 用户名
     * @param pid 商品名
     * @param num 添加商品的数量
     * @param username 修改者名
     */
    void addToCart(Integer uid, Integer pid, Integer num, String username);
```

**3、实现类**

```java
@Service
public class CartServiceImpl implements ICartService {
    @Autowired
    CartMapper cartMapper;
    @Autowired
    ProductMapper productMapper;
    @Override
    public void addToCart(Integer uid, Integer pid, Integer num, String username) {
        Cart res = cartMapper.findByUidAndPid(uid, pid);
        //当用户没有将该商品加入到某个用户购物车，则创建一个新购物车存改商品
        if(res == null){
            Cart cart = new Cart();
            Product product = productMapper.findById(pid);
            Long price = product.getPrice();
            cart.setPrice(price);
            cart.setPid(pid);
            cart.setNum(num);
            cart.setUid(uid);
            cart.setCreatedUser(username);
            cart.setCreatedTime(new Date());
            cart.setModifiedUser(username);
            cart.setModifiedTime(new Date());
            Integer integer = cartMapper.insertCart(cart);
            if(integer != 1){
                throw new InsertException("添加购物车错误");
            }
        }else{//如果购物车已经存在该商品，则更新商品数量
            num += res.getNum();
            Integer integer = cartMapper.updateNumByCid(num, res.getCid(), username, new Date());
            if(integer != 1){
                throw new UpdateException("修改商品数量发生错误");
            }
        }
    }
}
```

**4、测试**

```java
@SpringBootTest
public class CartServiceTest{
    @Autowired
    private ICartService cartService;

    @Test
    public void addToCart() {
        try {
            Integer uid = 4;
            Integer pid = 10000007;
            Integer amount = 1;
            String username = "Tom";
            cartService.addToCart(uid, pid, amount, username);
            System.out.println("OK.");
        } catch (ServiceException e) {
            System.out.println(e.getClass().getSimpleName());
            System.out.println(e.getMessage());
        }
    }
}
```

#### 控制层

**1、处理异常**‘

无需处理

**2、设计请求**

```
请求路径：/carts/add_to_cart/
请求参数：@PathVariable("cid") Integer cid, HttpSession session
请求类型：POST
响应结果：JsonResult<Void>
```

**3、创建控制器方法处理请求**

```java
@RestController
@RequestMapping("carts")

    /**
     * 增加商品数量
     * @param session 会话
     * @param pid 商品id，通过url获取
     * @param num 通过前端的num标签获取
     * @return
     */
public class CartController extends BaseController{
    @Autowired
    ICartService cartService;
    @RequestMapping("add_to_cart")
    public JsonResult<Void> addToCart(HttpSession session, Integer pid, Integer num){
        cartService.addToCart(getUidFromSession(session), pid, num, getUsernameFromSession(session));
        return new JsonResult<>(OK);
    }
}
```

**4、测试**

#### 前端

设计加入购物车的点击事件

```js
$("#btn-add-to-cart").click(function (){
   $.ajax({
      url: "/carts/add_to_cart",
      type: "POST",
      data: {
         pid: id,//上面获取的商品id
         num: $("#num").val()//标签mun的属性值
      },
      dataType: "JSON",
      success: function (json) {
         if(json.state == 200){
            alert("商品添加成功")
         }else{
            alert("商品添加失败")
         }
      },
      error: function (xhr) {
         alert("添加商品时遇到意外的错误" + xhr.message)
      }
   });
});
```

### 展示购物车列表

