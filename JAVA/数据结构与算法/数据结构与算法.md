# 经典算法面试题

#### 一、汉诺塔游戏

游戏要求：将A塔的所有圆盘移动到C塔。并且规定，小圆盘上不能1放大圆盘，在三根柱子之间一次只能移动一个圆盘。

<img src="C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220118122121163.png" alt="image-20220118122121163" style="zoom:67%;" />

应用算法：分治算法。

#### 二、八皇后问题

游戏要求：在8 × 8的国际象棋上摆放八个皇后，使其不能相互攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。【92种】回溯算法、分治算法。

#### 三、马踏棋盘算法

游戏要求：将马随机放在国际象棋的8×8棋盘中的某个方格中，马走日字移动，要求每个方格只能进入一次，走遍棋盘上全部64个方格。

应用算法：图的深度优化遍历算法（DFS）+贪心算法优化

## 算法的重要性

1、算法是程序的灵魂，优秀的算法可以在海量的数据计算时，依然保持告诉计算。

2、很多一线IT公司（大厂），都会有数据结构和算法面试题（肯定会有）

## 数据结构和算法的介绍 

1、程序=数据结构+算法

2、数据结构是算法的基础，想要学好算法，需要把数据结构学到位。



数据结构分为线性结构和非线性结构。

### 线性结构



1、线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。

2、线性结构有两种存储结构，顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表成为顺序表。

3、链式存储的线性表成为链表，链表中的元素不一定是连续的，元素节点存放数据元素以及相邻元素的地址信息。

### 非线性结构

包括：二维数组，多维数组，广义表，树结构，图结构。

## 稀疏数组

二维数组可以有用元素很少（有很多0），这时，应该将二维数组转化为更简单的稀疏数组（0很多时适用）。

要求：将普通二维数组转换为稀疏数组，再将稀疏数组在转化为普通二维数组。

```java
public class 稀疏数组 {
    public static void main(String[] args) {
        int[][] a = new int[11][11];
        a[1][2]=1;
        a[2][3]=2;
        int sum=0;
        for (int []x:a){
            for(int date:x){
                if(date!=0){
                    sum++;
                }
            }
        }
        int[][] b = new int[sum+1][3];
        b[0][0]=11;
        b[0][1]=11;
        b[0][2]=sum;
        int count=1;
        for(int i=0;i<a.length;i++){
            for (int j=0;j<a[0].length;j++){
                if(a[i][j]!=0){
                    b[count][0]=i;
                    b[count][1]=j;
                    b[count][2]=a[i][j];
                    count++;
                }
            }
        }
        for(int[] x:b){
            for (int date:x){
                System.out.printf("%d\t",date);
            }
            System.out.println();
        }
        int count1=1;
        int[][] c = new int[11][11];
        for(int i=1;i<b.length;i++){
            c[b[i][0]][b[i][1]]=b[i][2];
        }
        for(int i=0;i<c.length;i++){
            for (int j=0;j<c[0].length;j++) {
                System.out.printf("%d\t",c[i][j]);
                }
            System.out.println();
            }
        }
    }
```

## 队列

#### 1、用数组模拟队列

1、编写一个ArrayQueue类，存队列各个属性信息。

2、创建队列的构造器，传入数组大小，设置头尾。

3、创建判满方法。

4、创建判空方法

5、创建添加数据的方法（先判满）

6、创建取出数据的方法（先判空）

7、显示所有数据的方法（遍历），显示对头

### 构造好队列

```
class ArrayQueue{
    private int MaxSize;
    private int front;
    private int rear;
    private int[] arr;

    ArrayQueue(int max){
        MaxSize=max;
        front=-1;
        rear=-1;
        arr=new int[MaxSize];
    }
    public Boolean Isfull(){//判满方法
        return rear==MaxSize-1;
    }
    public Boolean Isempty(){//判空方法
        return front==rear;
    }
    public int adddate(int date){//添加数据
        if (Isfull()){
            throw new RuntimeException("队列已满");//抛出错误，让后面的try catch 接受错误，处理错误，打印出‘队列已满’,不然执行的时候报错，直接跳出程序。
        }
        rear++;
        arr[rear]=date;
        return 0;
    }
    public int getdate(){//取出数据
        if(Isempty()){
            throw new RuntimeException("队列是空的");
        }
        front++;
        return arr[front];//front现在指向哪，就代表哪已被取出

    }
    public void showdate(){//展示数据
        if (Isempty()){
            System.out.println("数据是空的");
        }
        else{
            for(int i=0;i<MaxSize;i++){
                System.out.printf("arr[%d]=%d\t\n",i,arr[i]);
            }
        }
    }
    public int showhead(){//展示头部
        if (Isempty()){
            throw new RuntimeException("队列是空的");
        }
        else
            return arr[front+1];//代表第一个数据
    }
   }
```

### 测试代码

```java
public class Text {
    public static void main(String[] args) {
        ArrayQueue q = new ArrayQueue(3);
        char key;
        Scanner scanner = new Scanner(System.in);
        boolean ooo=true;
        while (ooo){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据");
            System.out.println("g(get):取出数据");
            System.out.println("h(head):查看头数据");
            key=scanner.next().charAt(0);//接受一个字母，如果输入一串字母，则接受第一个。
            switch (key){
                case 's':{
                    q.showdate();
                    break;
                }
                case 'a':{
                    try {
                        int date= scanner.nextInt();
                        q.adddate(date);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 'g':{
                try {
                    System.out.println("已取出数据："+q.getdate());
                }catch (Exception e){
                    System.out.println(e.getMessage());
                }
                break;
                }
                case 'h':{
                    try {
                        System.out.println("现在头数据是："+q.showhead());
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 'e':{
                    System.out.println("正在退出程序~~~");
                    ooo=false;
                    break;
                }
                default:{
                    break;
                }
            }
        }
    }
}
```



### 缺点

数组只能用一次，当front==rear时，即使是空，也不能加数据了。

### 环形队列

![image-20220123134921556](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220123134921556.png)

队空条件：front=rear.

堆满条件：(rear+1)%MaxSize=front.

进队操作：rear=(rear+1)%MaxSize.

出队操作：front=(front+1)%MaxSize.

元素个数：(rear+MaxSize-front)%MaxSize.//(rear-front)%MaxSize可能为负数

### 架构代码：

```java
class CircleArray{
    private int MaxSize;
    private int front;
    private int rear;
    private int[] arr;

    CircleArray(int max){
        MaxSize=max;
        front=0;
        rear=0;
        arr=new int[MaxSize];
    }
    public Boolean Isfull() {
        return (rear + 1) % MaxSize == front;
    }
    public Boolean Isempty(){
        return front==rear;
    }
    public int adddate(int date){
        if (Isfull()){
            throw new RuntimeException("队列已满");
        }
        arr[rear]=date;
        rear=(rear+1)%MaxSize;
        return 0;
    }
    public int getdate(){
        if(Isempty()){
            throw new RuntimeException("队列是空的");
        }
        int date=front;
        front=(front+1)%MaxSize;
        return arr[date];

    }
    public void showdate(){
        if (Isempty()){
            System.out.println("数据是空的");
        }
        else{
            for(int i=front;i<front+(rear+MaxSize-front)%MaxSize;i++){
                System.out.printf("arr[%d]=%d\t\n",i%MaxSize,arr[i%MaxSize]);
            }
        }
    }
    public int showhead(){
        if (Isempty()){
            throw new RuntimeException("队列是空的");
        }
        else
            return arr[front];
    }

    public static void main(String[] args) {

    }
}
```

### 测试代码：

```java
import java.util.Scanner;

public class Text {
    public static void main(String[] args) {
        CircleArray c = new CircleArray(5);
        char key;
        Scanner scanner = new Scanner(System.in);
        boolean ooo=true;
        while (ooo){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据");
            System.out.println("g(get):取出数据");
            System.out.println("h(head):查看头数据");
            key=scanner.next().charAt(0);
            switch (key){
                case 's':{
                    c.showdate();
                    break;
                }
                case 'a':{
                    try {
                        int date= scanner.nextInt();
                        c.adddate(date);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 'g':{
                    try {
                        System.out.println("已取出数据："+c.getdate());
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 'h':{
                    try {
                        System.out.println("现在头数据是："+c.showhead());
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 'e':{
                    System.out.println("正在退出程序~~~");
                    ooo=false;
                    break;
                }
                default:{
                    break;
                }
            }
        }
    }
}
```

# 单向链表

1、链表是以节点的方式存储的。

2、每个节点包括data域，next域（指向下一个节点）

3、链表的各个节点不一定是连续存放的。

4、链表分带头结点的链表和没有带头结点的链表。

![image-20220124112753468](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220124112753468.png)

### 创建一个链表类，通过new实例化出不同的梁山好汉，对好汉链表进行增删查改：

```java
class HeroNode{
    public int number;
    public String name;
    public String nickname;
     HeroNode next;
    HeroNode(int number,String name,String nickname){
        this.number=number;
        this.name=name;
        this.nickname=nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "number=" + number +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
class SingleLikeList{

        private HeroNode head = new HeroNode(0,"","");

    public void add(HeroNode h){
        HeroNode temp=head;
        while (true){
            if(temp.next==null){
                temp.next=h;
                break;
            }
            temp=temp.next;
        }
    }
    public void addbyorder(HeroNode h){//按顺序添加
        HeroNode temp=head;
        boolean x=false;
        if(temp.next==null){
            System.out.println("数组为空，可以添加");
        }
        while (true){
            if (temp.next==null){
                System.out.println("已到最后位置，可以添加");
                break;
            }else if(temp.next.number>h.number){
                System.out.println("后面可以插入");
                break;
            }else if(temp.next.number==h.number) {
                x=true;
                break;
            }
                temp=temp.next;
        }
        if (x==true){
            System.out.println("好汉已存在，不可加入");
        }else {
            h.next=temp.next;
            temp.next=h;
        }
    }
    public void update(HeroNode h){
        if(head.next==null){
            System.out.println("数组为空，不可修改~~");
        }
        HeroNode temp=head;
        boolean x=false;
        while (true){
            if(temp.next==null){
                System.out.println("已遍历到最后");
                break;
            }else if(temp.next.number==h.number){
                x=true;
                break;
            }
            temp=temp.next;
        }
        if(x){
            temp.next.name=h.name;
            temp.next.nickname=h.nickname;
        }else {
            System.out.println("没找到要修改的值");
        }
    }
    public void delete(int number){//要删除的好汉
        if(head.next==null){
            System.out.println("列表为空，不能删除");
        }
        boolean x=false;
        HeroNode temp=head;
        while (true){
            if(temp.next==null){
                break;
            }
            else if(temp.next.number==number){
                x=true;
                break;
            }
            temp=temp.next;
        }
        if(x){
            temp.next=temp.next.next;
        }else {
            System.out.println("删不了");
        }
    }
    public void show(){
        HeroNode temp=head.next;
        while (true){
            if (temp==null){
                break;
            }
            System.out.println(temp);
            temp=temp.next;
        }
    }

    public static void main(String[] args) {
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(4, "哈哈", "哈哈");
        HeroNode hero4 = new HeroNode(3, "凉凉", "凉凉");
        HeroNode hero5 = new HeroNode(6, "哦哦", "哦哦");
        HeroNode hero6 = new HeroNode(5, "喜喜", "喜喜");
        HeroNode hero7 = new HeroNode(4, "呵呵", "呵呵");
        SingleLikeList S = new SingleLikeList();
        S.add(hero3);
        S.add(hero1);
        S.addbyorder(hero4);
//        S.delete(1);
//        S.addbyorder(hero6);
//        S.addbyorder(hero6);
//        S.addbyorder(hero2);
          S.show();
        S.delete(1);
        S.show();

    }
}
```

注意，添加和删除操作，辅助节点temp必须引用的是head，不能是head.next,不然temp被修改，而head不会变化。当temp=head,temp.next变化，head.next也会根着变化，所有head也发生了变化。

查看和修改，可以先让让temp=head.next;因为1查看不影响链表的属性，而修改也只要修改节点的内部属性，而没有修改节点的地址。



#  双向链表

使用带head头节点的双向链表实现—梁山好汉排行

对比单向链表的优点：单向链表的查找只能是一个方向，而双向链表可以向前向后查找。

单向链表不能自我删除，需要辅助节点，查找辅助节点的前一个节点来删除当前节点。而双向链表可以自我删除节点。即直接让temp=head.next;temp就是当前要操作的节点。

代码：

```java
class HeroNode2{
    public int number;
    public String name;
    public String nickname;
    HeroNode2 next;
    HeroNode2 pre;
    HeroNode2(int number,String name,String nickname){
        this.number=number;
        this.name=name;
        this.nickname=nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "number=" + number +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
class SingleLikeList2{

    private HeroNode2 head = new HeroNode2(0,"","");

    public void add(HeroNode2 h){
        HeroNode2 temp=head;
        while (true){
            if(temp.next==null){
                temp.next=h;
                h.pre=temp;
                break;
            }
            temp=temp.next;
        }
    }
    public void addbyorder(HeroNode2 h){//按顺序添加
        HeroNode2 temp=head;
        boolean x=false;
        if(temp.next==null){
            System.out.println("数组为空，可以添加");
        }
        while (true){
            if (temp.next==null){
                System.out.println("已到最后位置，可以添加");
                break;
            }else if(temp.next.number>h.number){
                System.out.println("后面可以插入");
                break;
            }else if(temp.next.number==h.number) {
                x=true;
                break;
            }
            temp=temp.next;
        }
        if (x==true){
            System.out.println("好汉已存在，不可加入");
        }else {
            h.next=temp.next;          //插入新的节点要重新建立新的next，pre关系.
            if(temp.next!=null) {
                temp.next.pre = h;
            }
            temp.next=h;
            h.pre=temp;
        }
    }
    public void update(HeroNode2 h){
        if(head.next==null){
            System.out.println("数组为空，不可修改~~");
        }
        HeroNode2 temp=head;
        boolean x=false;
        while (true){
            if(temp.next==null){
                System.out.println("已遍历到最后");
                break;
            }else if(temp.next.number==h.number){
                x=true;
                break;
            }
            temp=temp.next;
        }
        if(x){
            temp.next.name=h.name;
            temp.next.nickname=h.nickname;
        }else {
            System.out.println("没找到要修改的值");
        }
    }
    public void delete(int number){//要删除的好汉
        if(head.next==null){
            System.out.println("列表为空，不能删除");
            return;
        }
        boolean x=false;
        HeroNode2 temp=head.next;
        while (true){
            if(temp==null){
                break;
            }
            else if(temp.number==number){
                x=true;
                break;
            }
            temp=temp.next;
        }
        if(x){
            temp.pre.next=temp.next;
            if(temp.next!=null){
                temp.next.pre=temp.pre;
            }
        }else {
            System.out.println("删不了");
        }
    }
    public void show(){
        HeroNode2 temp=head.next;
        while (true){
            if (temp==null){
                break;
            }
            System.out.println(temp);
            temp=temp.next;
        }
    }

    public static void main(String[] args) {
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(4, "哈哈", "哈哈");
        HeroNode2 hero4 = new HeroNode2(3, "凉凉", "凉凉");
        HeroNode2 hero5 = new HeroNode2(6, "哦哦", "哦哦");
        HeroNode2 hero6 = new HeroNode2(5, "喜喜", "喜喜");
        HeroNode2 hero7 = new HeroNode2(4, "呵呵", "呵呵");
        SingleLikeList2 S = new SingleLikeList2();
//        S.add(hero3);
//        S.add(hero1);
        S.addbyorder(hero4);
//        S.delete(1);
        S.addbyorder(hero6);
//        S.addbyorder(hero6);
        S.addbyorder(hero2);
        System.out.println("----------");
        S.show();
        System.out.println("---------");
        S.delete(3);
        S.show();
        System.out.println("----------");

        S.delete(5);
        S.delete(2);
        System.out.println("-----------");
        System.out.println("无了，哈哈");
        S.show();
        System.out.println("------------");

    }
}
```

注意：删除和添加,要判断删除和添加的下一个节点是否为null，如果为null，就不用执行temp.next.pre=tmp.pre;



# 环形链表

```java
class Boy{
    private int number;
    private Boy next;
    public Boy(int number){
        this.number=number;
    }

    public int getNumber() {
        return number;
    }

    public Boy getNext() {
        return next;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public void setNext(Boy next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Boy{" +
                "number=" + number +
                ", next=" + next.number +
                '}';
    }
}
class CircleLinkedList{
    Boy first;
    public void add(int num){
        Boy pointboy = first;
        if(num<1){
            System.out.println("添加失败");
            return;
        }
        for(int i=1;i<=num;i++){
//            if(i == 1){
//                if(pointboy == null){
//                    pointboy = new Boy(i);
//                    pointboy.setNext(pointboy);
//                }else{
//                    pointboy.setNumber(i);
//                }
//            }else{
//                Boy temp = pointboy.getNext();
//                pointboy.setNext(new Boy(i));
//                pointboy = pointboy.getNext();
//                pointboy.setNext(temp);
//            }

            Boy boy = new Boy(i);
            if(i==1){
                first=boy;//first值固定
                first.setNext(first);
            pointboy=first;//辅助节点从起点出发

            }else {
                pointboy.setNext(boy);
                boy.setNext(first);//将新建节点指向起点位置
                pointboy=boy;//辅助接点向后走一步。
            }
        }
//        first = pointboy.getNext();

    }
    public void show(){
        Boy pointboy = first;
        if(pointboy==null){
            return;
        }
        System.out.println(pointboy);
        pointboy = pointboy.getNext();
        while (pointboy != first){
            System.out.println(pointboy);
            pointboy = pointboy.getNext();
        }
    }

    public static void main(String[] args) {
        CircleLinkedList c = new CircleLinkedList();
        c.add(5);
        c.show();
    }
}
```

## 栈

应用场景：

（1）子程序的调用

（2）处理递归调用

（3）表达式的转换（中缀表达式转后缀表达式）与求值（实际解决）。

（4）二叉树的遍历

（5）图形的深度优先（depth-first）搜索法。



### 接下来用一个数组完成栈的一些基本操作：

代码：

```java
public class Text {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayStack a = new ArrayStack(5);
        boolean x=true;
        while (x){
            System.out.println("p:(入栈)");
            System.out.println("o：（出栈）");
            System.out.println("s：（展示）");
            System.out.println("e:（退出）");
            char key=scanner.next().charAt(0);
            switch (key){
                case 'p':{
                    System.out.println("请输入一个要添加的数字：");
                    int value=scanner.nextInt();
                    a.push(value);
                    break;
                }
                case 'o':{
                    try {
                        System.out.println("已取出："+a.pop());
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 's':{
                    a.show();
                    break;
                }
                case 'e':{
                    scanner.close();
                    System.out.println("程序退出~~~");
                    x=false;
                    break;
                }
                default:{
                    break;
                }

            }
        }
    }
}
```

测试代码：

```java
public class Text {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayStack a = new ArrayStack(5);
        boolean x=true;
        while (x){
            System.out.println("p:(入栈)");
            System.out.println("o：（出栈）");
            System.out.println("s：（展示）");
            System.out.println("e:（退出）");
            char key=scanner.next().charAt(0);
            switch (key){
                case 'p':{
                    System.out.println("请输入一个要添加的数字：");
                    int value=scanner.nextInt();
                    a.push(value);
                    break;
                }
                case 'o':{
                    try {
                        System.out.println("已取出："+a.pop());
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                }
                case 's':{
                    a.show();
                    break;
                }
                case 'e':{
                    scanner.close();
                    System.out.println("程序退出~~~");
                    x=false;
                    break;
                }
                default:{
                    break;
                }

            }
        }
    }
}
```

### 用栈完成计算一个表达式（中缀表达式）的结果

1、通过一个index值（索引）,来遍历表达式

2、如果发现是一个数字，就直接入数栈

3、如果扫描发现是一个符号分下面两种情况。

（1）如果当前符号栈为空，直接当前符号入栈。

（2）如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个两个数，符号栈中pop出一个符号，进行计算，将得到结果，入数栈，然后将当前操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。

4、当前表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.

5、最后在数栈只有一个数字，就是表达式的结果

代码：缺点只能计算个位数的运算表达式。

```java
public class Calculator {
    public static void main(String[] args) {
        ArrayStack2 numberStack = new ArrayStack2(10);//创建两个栈
        ArrayStack2 operStack = new ArrayStack2(10);
        String expression="3+2*6-2";
        int index=0;
        int num1=0;
        int num2=0;
        int oper=0;
        int res=0;
        char ch=' ';
        while (true){
            ch=expression.substring(index,index+1).charAt(0);//将字符串以字符型逐一取出，判断
            if(operStack.IsOper(ch)){//如果是运算符
                if(operStack.Isempty()){
                    operStack.push(ch);
                }else{
                    if(operStack.priority(operStack.peektop())>operStack.priority(ch)){//比较运算符优先级大小
                        num1=numberStack.pop();
                        num2=numberStack.pop();
                        oper=operStack.pop();
                        res=numberStack.cal(num1,num2,oper);
                        numberStack.push(res);
                        operStack.push(ch);
                    }else {
                        operStack.push(ch);
                    }
                }
            }else {
                numberStack.push(ch-48);
            }
            index++;
            if(index>=expression.length()){
                break;
            }
        }
        while (true){
            if (operStack.Isempty()){
                break;
            }else {
                num1=numberStack.pop();
                num2=numberStack.pop();
                oper=operStack.pop();
                res=numberStack.cal(num1,num2,oper);
                numberStack.push(res);
            }
            System.out.printf("表达式%s的计算结果为：%d",expression,numberStack.pop());
        }
    }
}


 class ArrayStack2
{
    public int MaxSize;
    public int top=-1;
    public int[] stack;
    public ArrayStack2(int max){
        this.MaxSize=max;
        stack=new int[max];
    }
    Boolean Isfull(){
        return top==MaxSize-1;
    }
    Boolean Isempty(){
        return top==-1;
    }
    void push(int data){
        if(Isfull()){
            System.out.println("栈满，不可加入");
            return;
        }else {
            top=top+1;
            stack[top]=data;
        }
    }
    int pop(){
        if(Isempty()){
            throw new RuntimeException("栈空，不能取出");
        }else {
            int date=top;
            top--;
            return stack[date];
        }
    }
    void show(){
        for(int i=top;i>=0;i--){
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
    int peektop(){
        return stack[top];
    }
    int priority(int oper){//判断优先级,用switch也行
        if(oper=='+'||oper=='-'){
            return 0;
        }else if(oper=='*'||oper=='/'){
            return 1;
        }else
            return -1;
    }
    Boolean IsOper(int oper){
        return oper=='+'||oper=='-'||oper=='*'||oper=='/';
    }
    int cal(int num1,int num2,int oper){
        int value=0;
        switch (oper){
            case '+':{
                value=num1+num2;
                break;
            }
            case '-':{
                value=num2-num1;
                break;
            }
            case '*':{
                value=num1*num2;
                break;
            }
            case '/':{
                value=num2/num1;
                break;
            }
            default:
                break;
        }
        return value;
    }
}
```



逆波兰计算器（后缀表达式）

代码：缺点：表达式要有断点。

```java
public class 逆波兰表达式 {
}
class Poland{
    public static void main(String[] args) {
        String expression="3 4 + 5 * 6 -";
        List<String> i = change(expression);
        i=change(expression);
        System.out.println(calculate(i));
        }
    static List<String> change(String s){//将长字符串转化为一段一段的短字符串，以空格为断点，最后存入ArrayList
        String []a=s.split(" ");
        List<String> li = new ArrayList<>();
        for(String s1 :a){
            li.add(s1);
        }
        return li;
    }
    static int calculate(List<String> s){
        Stack<String> stack = new Stack<>();
        for(String i:s){
            if(i.matches("\\d+")){//正则表达式，找出数字字符串。
                stack.push(i);
            }else {
                int num2=Integer.parseInt(stack.pop());
                int num1=Integer.parseInt(stack.pop());
                int res=0;
                if(i.equals("+")){
                    res=num1+num2;
                }
                else if(i.equals("-")){
                    res=num1-num2;
                }
                else if(i.equals("*")){
                    res=num1*num2;
                }
                else if(i.equals("/")){
                    res=num1/num2;
                }
                stack.push(res+"");
            }

        }
        return Integer.parseInt(stack.pop());
    }
}
```

# 递归：

递归调用规则：

1、当程序执行到一个方法时，就会开辟一个独立的空间（栈）

2、每个空间的数据（局部变量），是独立的。

3、如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据。

4、递归必须向退出递归的条件逼近，否则就是无限递归了，栈会溢出。

5、当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法就执行完毕。

代码示例1:



```java
public class 递归 {
    public static void main(String[] args) {
        text(4);
    }
    public static void text(int x){
        if(x>2){
            text(x-1);
        }
        System.out.println(x);
    }
}
```

输入：2 3 4

![image-20220128144826293](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220128144826293.png)

代码实例2：

```java
public class 递归 {
    public static void main(String[] args) {
        text(4);
    }
    public static void text(int x){
        if(x>2){
            text(x-1);
        }else 
        System.out.println(x);
    }
}
```

只有x=2时进入else，3，4进入if。

代码实例3：阶层运算

```java
public class 递归 {
    public static void main(String[] args) {
        int res=text(4);
        System.out.println(res);
    }
    public static int text(int x){
        if(x==1){
            return 1;
        }else
        return text(x-1)*x;
    }
}
```



# 二分查找

查找对象必须有序，升序，降序都行。

```java
public class 二分查找 {
}
class BinarySearch{
    public static void main(String[] args) {
        int []a={1,2,55,66,83,99};
        System.out.println(search(0, a.length - 1, 99, a));

    }
    public static int search(int left,int right,int value,int a[]){
        int mid=(right+left)/2;
        if(a[right]<a[left]){//如果找不到，返回-1
            return -1;
        }
        if(value>a[mid]){//大于中间值，说明查找对象在右边，从右边递归。
            return search(mid+1,ri,value,a);
        }
        else if (value<mid){
            return search(left,mid-1,value,a);
        }else {
            return mid;
        }


    }
}
```

二分查找进化版：可以找出所有相同目标值的下标

代码：

```java
class BinarySearch{
    public static void main(String[] args) {
        int []a={1,1,1,2,55,66,83,99,99,99};
        System.out.println(search(0, a.length - 1, 1, a));

    }
    public static ArrayList<Integer> search(int left,int right,int value,int a[]){
        int mid=(right+left)/2;
        if(a[right]<a[left]){
            return new ArrayList<>();
        }
        if(value>a[mid]){
            return search(mid+1,a.length-1,value,a);
        }
        else if (value<mid){
            return search(0,mid-1,value,a);
        }else {
            ArrayList<Integer> li=new ArrayList<>();
            int temp=mid-1;
            while (true){//先向左找
                if(temp<0||a[temp]!=value){//不能调换顺序，因为当查找值再最左边，mid会到最左边,temp超出边界。
                    break;
                }
                li.add(temp);
                temp--;
            }
            li.add(mid);
            temp=mid+1;
            while (true){
                if(temp>a.length-1||a[temp]!=value){
                    break;
                }
                li.add(temp);
                temp++;
            }
            return li;
        }

    }
}
```

# 树

数组：查询元素效率高（二分查找等），但是添加（扩容，拷贝一份，在添加），删除要整体移动，效率低。ArrayList其实是维护了Object[]数组，里面有按比例扩容的方法。

链表：增加，删除效率较高，但是查询效率低（比如要找的数在最后一个，但是查询必须从头节点开始）。

所以，树诞生了，综合了前面两者的长处。



## 二叉排序树

![image-20220128180631555](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220128180631555.png)

查找1，两步（快）

添加13，只需两次（快）

删除5，两步（快），删除10（可能麻烦一点，但还是快）

 # 二叉树基本概念：



![image-20220128181341740](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220128181341740.png)

![image-20220128181522134](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220128181522134.png)

![image-20220128182152481](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220128182152481.png)

## 二叉树的先序、中序，后续遍历

代码：

```java
class BinTreeText{//测试
    public static void main(String[] args) {
        BinTree binTree = new BinTree();
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode hero1 = new HeroNode(2,"卢俊义");
        HeroNode hero2 = new HeroNode(3,"吴用");
        HeroNode hero3 = new HeroNode(4,"林冲");
        binTree.setRoot(root);//将宋江为头节点传入树的头节点
        root.setLeftson(hero1);//宋江的左子树为卢俊义
        root.setRightson(hero2);
        hero2.setRightson(hero3);
        binTree.inOrder();

    }
}

public class BinTree {//构建一棵树
    HeroNode root;//头节点

    public void setRoot(HeroNode root) {
        this.root = root;
    }
    public void preOrder(){
        if(root!=null){
            root.preOrder();
        }else
            System.out.println("头节点为空");
    }
    public void inOrder(){
        if(root!=null){
            root.inOrder();
        }else
            System.out.println("头节点为空");
    }
    public void lastOrder(){
        if(root!=null){
            root.lastOrder();
        }else
            System.out.println("头节点为空");
    }
}
class  HeroNode{
    private HeroNode leftson;
    private HeroNode rightson;
    private int number;
    private String name;

    public HeroNode(int number,String name) {
        this.number = number;
        this.name=name;
    }

    public HeroNode getLeftson() {
        return leftson;
    }

    public void setLeftson(HeroNode leftson) {
        this.leftson = leftson;
    }

    public HeroNode getRightson() {
        return rightson;
    }

    public void setRightson(HeroNode rightson) {
        this.rightson = rightson;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                ", number=" + number +
                ", name='" + name + '\'' +
                '}';
    }
    //先序遍历
    public void  preOrder(){
        System.out.println(this);//谁调用preOrder,this就指向谁，刚开始是root节点（宋江）
        if(leftson!=null){//卢俊义
             leftson.preOrder();
        }
        if (rightson!=null){//吴用、林冲
            rightson.preOrder();//1,2,3,4
        }
    }

//中序遍历
public void  inOrder(){
    if(leftson!=null){
        leftson.inOrder();
    }
    System.out.println(this);//刚开始this指向leftson.preOder(卢俊义)，后输出宋江
    if (rightson!=null){
        rightson.inOrder();//2,1,3,4
    }4
}
//后序遍历
public void  lastOrder(){
    if(leftson!=null){
        leftson.lastOrder();
    }
    if (rightson!=null){
        rightson.lastOrder();
    }
    System.out.println(this);//刚开始this指向 leftson.preOrder();,先输出卢俊义，后this指向林冲，后吴用，最后跳出宋江的if (rightson!=null),输出宋江。
}//2,4,3,1
}
```

## 二叉树的查找

在之前的二叉树添加查找功能。

```java
class BinTreeText{
    public static void main(String[] args) {
        BinTree binTree = new BinTree();
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode hero1 = new HeroNode(2,"卢俊义");
        HeroNode hero2 = new HeroNode(3,"吴用");
        HeroNode hero3 = new HeroNode(4,"林冲");
        binTree.setRoot(root);
        root.setLeftson(hero1);
        root.setRightson(hero2);
        hero2.setRightson(hero3);
//        binTree.lastOrder();
        binTree.preOrdersearch(4);
        binTree.inOrdersearch(4);
        binTree.lastOrdersearch(1);


    }
}

public class BinTree {
    HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }
    public void preOrder(){
        if(root!=null){
            root.preOrder();
        }else
            System.out.println("头节点为空");
    }
    public void inOrder(){
        if(root!=null){
            root.inOrder();
        }else
            System.out.println("头节点为空");
    }
    public void lastOrder(){
        if(root!=null){
            root.lastOrder();
        }else
            System.out.println("头节点为空");
    }
    public void preOrdersearch(int num){
        if(root!=null){
            System.out.println(root.preOrdersearch(num));
        }
        else
            System.out.println("头节点为空");
    }
    public void inOrdersearch(int num){
        if(root!=null){
            System.out.println(root.inOrdersearch(num));
        }
        else
            System.out.println("头节点为空");
    }
    public void lastOrdersearch(int num){
        if(root!=null){
            System.out.println(root.lastOrdersearch(num));
        }
        else
            System.out.println("头节点为空");
    }
}
class  HeroNode{
    private HeroNode leftson;
    private HeroNode rightson;
    private int number;
    private String name;

    public HeroNode(int number,String name) {
        this.number = number;
        this.name=name;
    }

    public HeroNode getLeftson() {
        return leftson;
    }

    public void setLeftson(HeroNode leftson) {
        this.leftson = leftson;
    }

    public HeroNode getRightson() {
        return rightson;
    }

    public void setRightson(HeroNode rightson) {
        this.rightson = rightson;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                " number=" + number +
                ", name='" + name + '\'' +
                '}';
    }
    //先序遍历
    public void  preOrder(){
        System.out.println(this);
        if(leftson!=null){
             leftson.preOrder();
        }
        if (rightson!=null){
            rightson.preOrder();
        }
    }

//中序遍历
public void  inOrder(){
    if(leftson!=null){
        leftson.inOrder();
    }
    System.out.println(this);
    if (rightson!=null){
        rightson.inOrder();
    }
}
//后序遍历
public void  lastOrder(){
    if(leftson!=null){
        leftson.lastOrder();
    }
    if (rightson!=null){
        rightson.lastOrder();
    }
    System.out.println(this);
}
//前序查找
    public HeroNode preOrdersearch(int num){
        System.out.println("找");//计算递归次数
        HeroNode node=null;
        if(this.number==num){
            return this;
        }
        if (this.leftson!=null){
            node=this.leftson.preOrdersearch(num);
            if(node!=null) {//如果找到，左子树就会return一个node,没找到就不进入if，就查找右子树。
                return node;
            }
        }
        if(this.rightson!=null){
            node=this.rightson.preOrdersearch(num);
            return node;//遍历右子树已是最后一步，找不找得到都要return一个node（可能为空）。
        }
       return null;
    }
    //中序查找
    public HeroNode inOrdersearch(int num){
        HeroNode node=null;
        if (this.leftson!=null){
            node=this.leftson.inOrdersearch(num);
            if(node!=null){
                return node;
            }
        }
        System.out.println("找");
        if(this.number==num){
            return this;
        }
        if(this.rightson!=null){
            node=this.rightson.inOrdersearch(num);
                return node;//遍历右子树已是最后一步，找不找得到都要return一个node（可能为空）。
        }
        return null;
    }
    //后续遍历
    public HeroNode lastOrdersearch(int num){
        HeroNode node=null;
        if (this.leftson!=null){
            node=this.leftson.lastOrdersearch(num);
            if(node!=null){
                return node;
            }
        }
        if(this.rightson!=null){
            node=this.rightson.lastOrdersearch(num);
                if(node!=null){
                    return node;
                }
        }
        System.out.println("找");
        if(this.number==num){
            return this;
        }
        return node;//查找父节点是最后一步，找不找得到都要return一个node（可能为空）。

    }
}
```

## 二叉树删除节点

思路：规定如果删除叶子节点，则删除该节点，如果删除的节点是非叶子节点，则删除该字数。

定义一个单向的二叉树，删除该节点只能通过判断父类.leftson或者.rightson来删除，不能通过本身判断来删除，不然this=null，非法（this是关键字），就像单链表删除一样，只能通过本身前一个节点本身指向下一个节点来删除自己。

代码：

```java
BinTree：
  //删除节点
    public void delete(int num){
        if(root.getNumber()==num){
            root=null;
        }else {
            root.delete(num);
        }
    }
```

```java
 HeroNode：
    public void delete(int num){
        if(this.leftson!=null&&this.leftson.getNumber()==num){
            this.leftson=null;
            return;
        }
        if(this.rightson!=null&&this.rightson.getNumber()==num){
            this.rightson=null;
            return;
        }
        if(this.leftson!=null){
            this.leftson.delete(num);
        }
        if (this.rightson!=null){
            this.rightson.delete(num);
        }
    }
```

## 顺序存储二叉树实现

要求：

数组存储方式和二叉树的存储方式可以互相转换（一般为完全二叉树），如图：

![image-20220130234657719](C:\Users\鹤\AppData\Roaming\Typora\typora-user-images\image-20220130234657719.png)



用数组完成先序，中序，后续遍历。

### 思路：

数组中第n个元素的左子节点为2*n+1，右子节点为2*n+2，父节点为（n-1）/2。n为数组元素下标。

代码：

```java
public class ArrayBinTree {
    private int []arr;
    ArrayBinTree(int []a){
        this.arr=a;
    }
    public void preOrder(int index){
       if(arr==null||arr.length==0){
           System.out.println("该数组为空数组");
           return;
       }else {
           System.out.printf("%d\t",arr[index]);

       }
       if(index*2+1<arr.length){//相当于如果左子节点不为空
           preOrder(index*2+1);
       }
        if(index*2+2<arr.length){//相当于如果右子节点不为空
            preOrder(index*2+2);
        }
    }

    public void inOrder(int index){
        if(arr==null||arr.length==0){
            System.out.println("该数组为空数组");
            return;
        }

        if(index*2+1<arr.length){//相当于如果左子节点不为空
            inOrder(index*2+1);
        }
        System.out.printf("%d\t",arr[index]);
        if(index*2+2<arr.length){//相当于如果右子节点不为空
            inOrder(index*2+2);
        }
    }
    public void postOrder(int index){
        if(arr==null||arr.length==0){
            System.out.println("该数组为空数组");
            return;
        }
        if(index*2+1<arr.length){//相当于如果左子节点不为空
            postOrder(index*2+1);
        }
        if(index*2+2<arr.length){//相当于如果右子节点不为空
            postOrder(index*2+2);
        }
        System.out.printf("%d\t",arr[index]);
    }
    public void preOrder(){
        this.preOrder(0);
    }
    public void inOrder(){
        this.inOrder(0);
    }
    public void postOrder(){
        this.postOrder(0);
    }
}

class Text{
    public static void main(String[] args) {
        int [] a={1,2,3,4,5,6,7};
        ArrayBinTree ar = new ArrayBinTree(a);
        ar.preOrder();
        System.out.println();
        ar.inOrder();
        System.out.println();
        ar.postOrder();

    }

}
```

## 二叉排序树（BST）

二叉排序树，汲取了二分法的高效搜索，和链表的高效添加。

### 二叉排序树的创建和遍历

代码：

```java
package 二叉排序树;
class Text{
    public static void main(String[] args) {
        int []a={7,3,10,12,5,1,9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for(int i=0;i<a.length;i++){
            binarySortTree.add(new Node(a[i]));
        }
        binarySortTree.inOrder();
    }
}
public class BinarySortTree {
    private Node root;

    public void add(Node node){
        if(root==null){
            root=node;
        }else {
            root.add(node);
        }
    }
    public void inOrder(){
        if(root==null){
            System.out.println("该树为空树");
            return;
        }else {
            root.inOrder();
        }
    }

}
class Node{
    Node left;
    Node right;
    int value;

    Node(int value){
        this.value=value;
    }
    public void add(Node node){
        if(node==null){
            return;
        }
        if(this.value>node.value){
            if(this.left==null){
                this.left=node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right==null){
                this.right=node;
            }else {
                this.right.add(node);
            }
        }
    }
    //中序遍历
    public void inOrder(){
        if(this.left!=null){
            this.left.inOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.inOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```

## 二叉排序树节点删除

### 思路

#### 情况一：删除叶子节点。

1、找到要删除的节点target。

2、找到target的父节点father。

3、确定target是father的左节点还是右节点。

4、如果是左节点：father.left=null;

​      如果是右节点: father.right=null;

#### 情况二：删除非叶子节点

该情况又分两种情况：

情况一：删除的节点有一个子节点：

1、找到要删除的节点target。

2、找到target的父节点father。

3、确定target拥有左子节点还是右子节点。

4、确定target是father的左节点还是右节点。

5、如果target有左子节点

（1）如果target是father的左子节点

father.left=target.left

(2)如果targetNode是father的右子节点

father.right=target.left

6、如果targetNode有右子节点

（1）如果target是father的左子节点

father.left=target.right

（2）如果target是father的右子节点

father.right=target.right

情况二：删除有两颗子树的节点：

1、找到要删除的节点target。（其实不是删除target,而是删除target右子树的最小节点）

2、找到target的父节点father。

3、从target的右子树找到最小节点。（也可以找左子树的最小节点）

4、删除这个右子树最小节点（因为是通过父节点删除，所以本身还在，可以返回值可以返回它，仍可以赋值）

5、在将该节点的value赋给target



```java
package 二叉排序树;
class Text{//测试功能
    public static void main(String[] args) {
        int []a={7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        for(int i=0;i<a.length;i++){
            binarySortTree.add(new Node(a[i]));
        }
        binarySortTree.inOrder();
        binarySortTree.delete(7);
        System.out.println("------------");
        binarySortTree.inOrder();
    }
}
public class BinarySortTree {//构建一棵树
    private Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    public void inOrder() {//中序遍历
        if (root == null) {
            System.out.println("该树为空树");
            return;
        } else {
            root.inOrder();
        }
    }
    public  Node rightTreeMin(Node node){
        while (node.left!=null){
            return rightTreeMin(node.left);
        }
        delete(node.value);
         return node;
    }
    public void delete(int value) {//删除操作
        if (root == null) {
            return;
        }
        Node target=root.search(value);//接受匹配的节点
        Node father=root.fathersearch(value);//接受匹配的节点的父节点
        if (target == null) {
            System.out.println("找不到该节点");
            return;
        }
        if (target.left == null && target.right == null) {//删除的是叶子节点
            if (root.right == null && root.left == null) {//该树只有一个节点，而且删的也是这个节点。
                root = null;
            } else if (father.left.value == value) {//如果找到的节点是该父节点的左子节点
                father.left = null;
            } else if (father.right.value == value) {//如果找到的节点是该父节点的右子节点
                father.right = null;
            }
        }else if(target.left!=null&&target.right!=null){//如果删除的是有两个个子节点的节点
            Node temp=rightTreeMin(target.right);
            target.value=temp.value;
        }else {//如果删除的是有一个子节点的节点
            if (target.left!=null){//如果他有左节点
                if (father.left.value==value){//如果是左子节点
                    father.left=target.left;
                }else {
                    father.right=target.left;
                }
            }else {
                if (father.left.value==value){//如果是左子节点
                    father.left=target.right;
                }else {
                    father.right=target.right;
                }
            }
        }

    }
}
class Node{
    Node left;
    Node right;
    int value;

    Node(int value){
        this.value=value;
    }
    public void add(Node node){
        if(node==null){
            return;
        }
        if(this.value>node.value){
            if(this.left==null){
                this.left=node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right==null){
                this.right=node;
            }else {
                this.right.add(node);
            }
        }
    }
    //中序遍历
    public void inOrder(){
        if(this.left!=null){
            this.left.inOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.inOrder();
        }
    }
//查找要删除的节点
    public Node search(int value){
        if(this.value==value){
            return this;
        }
        else if(this.value>value&&this.left!=null) {
            return this.left.search(value);
        }
         else if(this.value<value&&this.right!=null){
        return this.right.search(value);
     }else {
             return null;
        }
    }
    //查找要删除节点的父节点
    public Node fathersearch(int value){
        if((this.left!=null&&this.left.value==value)||(this.right!=null&&this.right.value==value)) {
            return this;
        }
        else{
            if(this.value>value&&this.left!=null){
                return this.left.fathersearch(value);
            }
            else if(this.value<value&&this.right!=null){
                return this.right.fathersearch(value);
            }
            else {
                return null;
            }
            }

    }
    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```
